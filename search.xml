<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6 规范详解、ESNext 规范</title>
    <url>/2021/04/28/ES6%20%E8%A7%84%E8%8C%83%E8%AF%A6%E8%A7%A3%E3%80%81ESNext%20%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>var、const、let、function<br>let 变量提升、作用域</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>1、箭头函数this是定义时决定，普通函数是使用时决定<br>2、简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span> <span class="string">'sss'</span></span><br></pre></td></tr></table></figure>
<p>3、不能做构造函数</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getFormatName()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static 静态方法，只能console.log(Test.getFormatName())</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li>for in</li>
</ol>
<ul>
<li>会调用原型链（obj.hasOwnProperty(key)）判断一下</li>
<li>不适合遍历数组</li>
</ul>
<ol start="2">
<li>for of</li>
</ol>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ol>
<li>Object.keys</li>
<li>Object.values</li>
<li>Object.entries</li>
<li>Object.getOwnPropertyNames</li>
<li>Object.getOwnPropertyDescriptor<br>对象的描述</li>
</ol>
<ul>
<li>configurable: true</li>
<li>writable: false</li>
<li>enumerable: true //枚举</li>
</ul>
<p>Reflect 一种js 优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj,name) 等</span><br></pre></td></tr></table></figure>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>array.slice() 可以浅拷贝</p>
<ul>
<li>Array.from<br>如何把arguments转换成真数组</li>
</ul>
<ol>
<li>[…arguments]</li>
<li>Array.from(arguments)</li>
<li>Array.prototype.slice.call(arguments)</li>
</ol>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript忍者秘籍第2版-笔记</title>
    <url>/2021/05/18/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><ul>
<li>生成器</li>
<li>Promise</li>
<li>代理</li>
<li>高级数组方法</li>
<li>Map</li>
<li>正则表达式</li>
<li>模块</li>
</ul>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote>
<p>Javascript 就是只开启了一个柜台</p>
</blockquote>
<ol>
<li>注册事件（addEventListener)</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>神书推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Actions, yes! + docker, yes yes!</title>
    <url>/2020/01/18/git-actions/</url>
    <content><![CDATA[<p>最近点开了一下Github Actions的技能树，在说真香之前，不得不说一下我踩过的这些前置任务的坑。找到这篇文章看的朋友大概也知道Github Actions是Github上的持续集成服务，它允许你在一些节点上（如提交代码，特定时间等）触发一些操作。这里我们实现自动部署应用到自己的服务器。<br><img src="/images/gitactions/bg2019091201.jpg" alt></p>
<hr>
<h2 id="首先要买一台服务器"><a href="#首先要买一台服务器" class="headerlink" title="首先要买一台服务器"></a>首先要买一台服务器</h2><p>过程略。。。</p>
<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>有细心看标题的朋友，应该知道我们是在<code>Github</code>（世界最大同性交友网站）上玩的<br><img src="/images/gitactions/ci.png" alt><br>在你的项目里面建一个.github文件夹（注意有一点.），然后再建一个workflows文件夹，里面再新建一个后缀为yml的文件（名字任意），完成以上步骤你大概就完成50%的工作量了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci.yml</span></span><br><span class="line">name: deploy to aliyun</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      <span class="comment"># 切换分支</span></span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@master</span><br><span class="line">      <span class="comment"># 使用 node:10</span></span><br><span class="line">      - name: use Node.js 10</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: 10</span><br><span class="line">      <span class="comment"># npm install</span></span><br><span class="line">      - name: npm install and build</span><br><span class="line">        run: |</span><br><span class="line">          yarn install</span><br><span class="line">          npm run build</span><br><span class="line">        env:</span><br><span class="line">          CI: <span class="literal">true</span></span><br><span class="line">      <span class="comment"># Deploy</span></span><br><span class="line">      - name: FTP-Deploy</span><br><span class="line">        uses: SamKirkland/FTP-Deploy-Action@2.0.0</span><br><span class="line">        env:</span><br><span class="line">          FTP_SERVER: <span class="variable">$&#123;&#123; secrets.REMOTE_HOST &#125;</span>&#125;</span><br><span class="line">          FTP_USERNAME: <span class="variable">$&#123;&#123; secrets.REMOTE_USER &#125;</span>&#125;</span><br><span class="line">          FTP_PASSWORD: <span class="variable">$&#123;&#123; secrets.REMOTE_PWD &#125;</span>&#125;</span><br><span class="line">          LOCAL_DIR: build</span><br><span class="line">          METHOD: sftp</span><br><span class="line">          REMOTE_DIR: /home/www</span><br><span class="line">          ARGS: --delete</span><br><span class="line">      - name: Docker-deploy</span><br><span class="line">        uses: appleboy/ssh-action@master</span><br><span class="line">        with:</span><br><span class="line">          host: <span class="variable">$&#123;&#123; secrets.REMOTE_HOST &#125;</span>&#125;</span><br><span class="line">          username: <span class="variable">$&#123;&#123; secrets.REMOTE_USER &#125;</span>&#125;</span><br><span class="line">          key: <span class="variable">$&#123;&#123; secrets.ACCESS_TOKEN &#125;</span>&#125;</span><br><span class="line">          script: |</span><br><span class="line">            docker <span class="built_in">exec</span> 你的docker容器名称 rm -rf /usr/share/nginx/html</span><br><span class="line">            docker cp /home/www 你的docker容器名称:/usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>展示一下我的终极配置，当然事情的发展没有这么简单</p>
<h3 id="配置详情"><a href="#配置详情" class="headerlink" title="配置详情"></a>配置详情</h3><p>git actions的奥妙之处就在于它有丰富的插件资源可以使用<br><img src="/images/gitactions/actions-market.png" alt><br>对于我们部署而言，前3个资源一般来说也是没问题的，最大的问题就在于发布，毕竟要和服务器打交道</p>
<blockquote>
<p>踩过的坑如下</p>
</blockquote>
<p>我之前发布用的模块是这个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deploy</span></span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: easingthemes/ssh-deploy@v2.0.7</span><br><span class="line">        env:</span><br><span class="line">          SSH_PRIVATE_KEY: <span class="variable">$&#123;&#123; secrets.ACCESS_TOKEN &#125;</span>&#125;</span><br><span class="line">          ARGS: <span class="string">"-avz --delete"</span></span><br><span class="line">          SOURCE: <span class="string">"build/"</span></span><br><span class="line">          REMOTE_HOST: <span class="variable">$&#123;&#123; secrets.REMOTE_HOST &#125;</span>&#125;</span><br><span class="line">          REMOTE_USER: <span class="variable">$&#123;&#123; secrets.REMOTE_USER &#125;</span>&#125;</span><br><span class="line">          TARGET: <span class="variable">$&#123;&#123; secrets.TARGET &#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<font color="green">哦，对，大家看到这些secrets的变量是不是很奇怪，其实是为了隐私安全问题，在github项目上Settings里Secrets上添加就好了</font>

<p>然后一直报这个错😢<br><img src="/images/gitactions/error.png" alt><br>服务器上什么的<code>ssh</code>都设置好了，在本地上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i id_rsa root@xxx.xxx.xxx.x</span><br></pre></td></tr></table></figure>
<p>用私密登录也是正常的，用其它ssh登录的actions也可以用，事情发展到不可开交的地步，战事一触即发，幸好我们还有其它别人写好的actions可以用，后来换上<code>FTP-Deploy-Action</code>，心情就变得愉快了，妈妈再也不用担心我写代码了</p>
<h3 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h3><p>如果没有用到docker的话，文章写到这里就可以结束了，把你的项目发布上了服务器，nginx配置指定一下域名和路径你就成功上岸了</p>
<p><font color="red">那什么是docker？</font></p>
<p><div style="float:left;margin-right:20px"><img width="360" src="/images/gitactions/docker.png"></div></p>
<p><div style="float:left"><img width="360" src="/images/gitactions/virtual.png"></div></p>
<p><div style="float:none;clear:both;"><br></div><br>遇事不决先上图</p>
<p>小弟不才，说说自己的见解，看图就很容易看出docker和虚拟机的最大区别，说人话就是，首先要说出docker里的容器和镜像的概念，容器就是根据你需要的镜像启动的，比如你有一个centos系统镜像，传统的虚拟机就是每个虚拟机上都用这个镜像往里面装一次，而docker就用这个镜像启动就可以了，这就生成了一个容器，而容器之间是独立的，这样就能做到资源的复用，扯远了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//我也是用的别人的nginx镜像，简单记录一下</span><br><span class="line">docker pull nginx:latest</span><br><span class="line">docker run --name nginx-test -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>那细心的朋友也发现，我最后的那个actions的配置其实就是一些ssh命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 你的docker容器名称 rm -rf /usr/share/nginx/html</span><br><span class="line">docker cp /home/www 你的docker容器名称:/usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>1、第一个就是先删除容器里的之前的项目，但也踩过坑，<code>docker exec</code>这个就是进入容器的命令了，之前我写的是<code>docker exec -it xxx /bin/bash</code>进去再<code>rm -rf</code>然后<code>exit</code>这样的，想法很美滋滋，但是ci命令上就报<code>err: the input device is not a TTY</code>后来才换成现在的命令<br>2、第二个就是把发上服务器的项目复制到容器里</p>
<h2 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h2><p>过程也略。。。（到目前为止，如无意外的话，你只要push一下代码，就会进入到我们设置好的“陷阱”里，一顿自动操作执行下来，你的网站就部署上去了）</p>
<h2 id="优化与改进（先挖好个坑）"><a href="#优化与改进（先挖好个坑）" class="headerlink" title="优化与改进（先挖好个坑）"></a>优化与改进（先挖好个坑）</h2><h3 id="自动发布到容器里（方案一）"><a href="#自动发布到容器里（方案一）" class="headerlink" title="自动发布到容器里（方案一）"></a>自动发布到容器里（方案一）</h3><p>1、将容器的sftp端口映射到服务器的某个端口上<br>2、在ftp actions里配置好对应的端口上传上去</p>
<h3 id="用dockerFile自制镜像-（方案二）"><a href="#用dockerFile自制镜像-（方案二）" class="headerlink" title="用dockerFile自制镜像 （方案二）"></a>用dockerFile自制镜像 （方案二）</h3><p>1、ci.yml里面就是执行自制的docker镜像run一下<br>2、镜像逻辑大概如下：拉取最新代码到容器-&gt;打包项目-&gt;覆盖项目上的自定义nginx配置文件到容器nginx的默认路径</p>
<p>参考文档：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程 - 阮一峰</a><br><a href="https://www.kai666666.top/2020/01/04/%E4%BD%BF%E7%94%A8GithubActions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88ECS%EF%BC%89/" target="_blank" rel="noopener">使用GithubActions自动部署应用到自己的服务器（ECS）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2016/02/14/hello-world/</url>
    <content><![CDATA[<p>博客换上Hexo主题</p>
<hr>
<h2 id="很久以前"><a href="#很久以前" class="headerlink" title="很久以前"></a>很久以前</h2><a id="more"></a>
<h3 id="就被它的这个"><a href="#就被它的这个" class="headerlink" title="就被它的这个"></a>就被它的这个</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">试试代码</span><br></pre></td></tr></table></figure>
<p>1001001111100101010110</p>
<blockquote>
<p>试试区块 这是一个区块</p>
</blockquote>
<p><em>这是斜体文字</em><br><strong>这是加粗的文字</strong></p>
<p><font size="4">我是变大的字</font></p>
<p><font color="green">我是有颜色字</font><br><img src="/images/module/exports.png" alt><br><code>代码字</code><br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html" target="_blank" rel="noopener">这是个链接</a></p>
<h3 id="文章目录吸引了"><a href="#文章目录吸引了" class="headerlink" title="文章目录吸引了"></a>文章目录吸引了</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">console.log(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure>
<p>列表？</p>
<ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<p>表格<br>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |</p>
<h3 id="今天终于能够换来试试"><a href="#今天终于能够换来试试" class="headerlink" title="今天终于能够换来试试"></a>今天终于能够换来试试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#life'</span>).html(<span class="string">'希望每个月能更一篇，以此为鉴'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="表示好兴奋"><a href="#表示好兴奋" class="headerlink" title="表示好兴奋"></a>表示好兴奋</h3><p>大家提提意见博客能有什么改造的地方</p>
<p>上标<sup>TM</sup><br>下标<sub>i</sub></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bye</span></span>()&#123;<span class="built_in">return</span> <span class="string">"恭喜你获得阅读我的第一篇博客成就！"</span>&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>第一次</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hooks的一些小感想</title>
    <url>/2022/01/14/hooks/</url>
    <content><![CDATA[<blockquote>
<p>这里文章说的都是hooks<sup>react</sup></p>
</blockquote>
<h3 id="那什么是hooks"><a href="#那什么是hooks" class="headerlink" title="那什么是hooks"></a>那什么是hooks</h3><p>故名思义 <code>Hooks</code> 译为钩子，<code>Hooks</code> 就是在函数组件内，负责钩进外部功能的函数。</p>
<p>(说了又好像没说)</p>
<h3 id="有什么爽的👌"><a href="#有什么爽的👌" class="headerlink" title="有什么爽的👌"></a>有什么爽的👌</h3><ul>
<li>函数组件原地飞升</li>
<li>不用管this了</li>
<li>生命周期也不用记那么多了</li>
</ul>
<p>开始结束的生命周期可以写在一起，代码更漂亮了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开波'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="comment">// ps.空数组就是只进入一次</span></span><br></pre></td></tr></table></figure>
<p>props的值的变化，xx值的变化都能放在一起监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'无论是数组还是对象，数据多深都能进（后来才发现也不是多深都能啦），这不比vue的watch爽？'</span>)</span><br><span class="line">  <span class="comment">// 那么useEffect是怎样监听数据变化的呢</span></span><br><span class="line">  <span class="comment">// 它和useLayoutEffect又有什么区别呢</span></span><br><span class="line">  <span class="comment">// 这要从hooks的基础概念链表说起，请往下看</span></span><br><span class="line">&#125;,[props.a,b])</span><br></pre></td></tr></table></figure>
<p>通过看useEffect的源码，我们不难发现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过看源码我们得知</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 我们知道它的对比方法是</span></span><br><span class="line"><span class="comment">// 其中里面的is是这个</span></span><br><span class="line"><span class="keyword">import</span> is <span class="keyword">from</span> <span class="string">'shared/objectIs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x: any, y: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    (x === y &amp;&amp; (x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y)) || (x !== x &amp;&amp; y !== y) <span class="comment">// eslint-disable-line no-self-compare</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectIs: <span class="function">(<span class="params">x: any, y: any</span>) =&gt;</span> boolean =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">Object</span>.is === <span class="string">'function'</span> ? <span class="built_in">Object</span>.is : is;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> objectIs;</span><br></pre></td></tr></table></figure>
<p>所以其实它就是用<code>Object.is</code>做比较</p>
<blockquote>
<p>有需要做深比较的可以用<code>ahooks</code>的<code>useDeepCompareEffect</code>，用法与 useEffect 一致，但 deps 通过 lodash 的<code>isEqual</code>进行深比较。</p>
</blockquote>
<ul>
<li>代码复用更高</li>
</ul>
<h3 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h3><h4 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">       &lt;p&gt;count=&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>大家可能会一直期待着数字的变化，但它就偏不，一直保持着1</p>
<p>事情为什么会发展成这样，那就要从底层的渲染开始说起</p>
<blockquote>
<p>初次渲染-&gt;执行APP-&gt;usestate设置count为初始0-&gt;1秒后state改变-&gt;视图更新-&gt;按照fiber链表执行hooks-&gt;useEffect deps 不变-&gt;然后1秒后的count始终都是0+1</p>
</blockquote>
<p>解决办法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有细心的网友可能会发现，网上其他地方可能会建议在useEffect的deps上加上count</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, [count])</span><br><span class="line"><span class="comment">// 这样确实能拿到最新的count</span></span><br><span class="line"><span class="comment">// ❌但是这里喔不建议这样写</span></span><br><span class="line"><span class="comment">// 因为你想想，每次count的更新它都会重新进去建一个新的定时器</span></span><br><span class="line"><span class="comment">// 以后画面就会很鬼畜</span></span><br></pre></td></tr></table></figure>
<p>建议版本方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(<span class="function"><span class="params">res</span>=&gt;</span>(res+<span class="number">1</span>))</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="comment">// setCount本身可以传方法，本来就是最新的值</span></span><br></pre></td></tr></table></figure>
<p>高级版本ref大法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单来说就是利用useRef返回的是同一个对象，指向同一片内存</span></span><br><span class="line"><span class="keyword">let</span> ref_ = useRef(<span class="number">1</span>)</span><br><span class="line">ref_.current++</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ref.current) <span class="comment">// 3</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="不能用判断或者随机函数"><a href="#不能用判断或者随机函数" class="headerlink" title="不能用判断或者随机函数"></a>不能用判断或者随机函数</h4><p>举个🌰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  useState(<span class="string">'first'</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> showSex = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ sex, setSex ] = useState(<span class="string">'男'</span>);</span><br><span class="line">    showSex = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的行为都是打咩的</p>
<p>原因是hooks的数据管理是用链表管理的，所以数据不能一时有一时没</p>
<p>举个不太恰当的例子，就像</p>
<blockquote>
<ul>
<li>数组[0]代表useState(‘A’)</li>
<li>数组[1]代表useState(‘B)</li>
<li>现在你突然把’A’删掉了，那就变成数组[0]代表useState(‘B’)了</li>
<li>那么你就不是你了，他也不是他了</li>
</ul>
</blockquote>
<h4 id="useCallBack-还是-useMemo"><a href="#useCallBack-还是-useMemo" class="headerlink" title="useCallBack 还是 useMemo"></a>useCallBack 还是 useMemo</h4><p>仅仅 <code>依赖数据</code> 发生变化, 才会重新计算结果，说是为了性能优化，起到缓存的作用，</p>
<p>这里说一个面试常问的<code>useCallBack</code> 和 <code>useMemo</code> 有什么区别？</p>
<p>网上各种解析长篇大论的，一句话其实就是</p>
<blockquote>
<p>useCallback 缓存钩子函数，useMemo 缓存返回值（计算结果）[当然useMemo也可以传入函数]。</p>
</blockquote>
<p>这个时候，有好奇宝贝就会问了,那用这个会多那么多代码量，有什么用呢</p>
<p>答案是：性能优化，这里就要涉及到更深层的react的渲染原理了，”比较更新！！”,react每次渲染的时候，它都把值和函数重新计算渲染，这里就会消耗点内存了，用上那2玩意，其实就是告诉react，我们没有变化，帮我存起来，不用再比较了</p>
<p>那么有些姓杠的小朋友，这时候就不耐烦了，站起来问道：为什么react不帮我们自动做这些优化呢，我就想静静地写代码，为什么还要考虑该不该包个<code>useCallBack</code></p>
<p>问得好，这里顺便@一下官方团队，希望相关单位能密切关注这个问题</p>
<p>还会有些害羞的小朋友会嘀咕着，为什么class组件的时候就不需要注意这些呢</p>
<p>个人鄙见：新旧版本的渲染方法其实差不多的，我觉得前端深入研究性能优化是没有前途的，框架或者浏览器，一次小小的版本更新，可能效果就远远胜过了你多少个日日夜夜的辛勤付出了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>hooks需好，但要小心使用</p>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样更改组件库的图标？</title>
    <url>/2019/03/14/icon-change/</url>
    <content><![CDATA[<p>想必很多前端现在都是用别人的组件库，ant-design、element-ui或者vant等，那么当组件上的icon和我们美丽动人的UI小姐姐画出的UI稿不一样的时候，你们会怎么做呢？<br><a id="more"></a></p>
<h2 id="组件api替换大法"><a href="#组件api替换大法" class="headerlink" title="组件api替换大法"></a>组件api替换大法</h2><p>1、组件本身提供api给你更换icon，换之则可<br>2、但每次使用都要替换也是挺麻烦的，可以尝试先封装一下，使用高阶组件</p>
<blockquote>
<p>可行性高，操作容易、略麻烦</p>
</blockquote>
<h2 id="源码copy大法"><a href="#源码copy大法" class="headerlink" title="源码copy大法"></a>源码copy大法</h2><p>1、不使用传统的npm install的包安装方法<br>2、将组件库的源码copy下来单独一个文件<br>3、修改源码组件对应的图标<br>4、或者自己建立一个私有的npm库将整个组件库推上去</p>
<blockquote>
<p>1、一次操作到位<br>2、但是组件库版本滞后</p>
</blockquote>
<h2 id="webpack修改大法"><a href="#webpack修改大法" class="headerlink" title="webpack修改大法"></a>webpack修改大法</h2><p>以ant-design为例子</p>
<h3 id="webpack上的resolve路径"><a href="#webpack上的resolve路径" class="headerlink" title="webpack上的resolve路径"></a>webpack上的resolve路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.less'</span>, <span class="string">'.css'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  <span class="built_in">alias</span>: &#123;</span><br><span class="line">    <span class="string">'@src'</span>: path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'./src'</span>),</span><br><span class="line">    <span class="string">'@package'</span>: path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'src'</span>, <span class="string">'package'</span>),</span><br><span class="line">    <span class="string">'@libs'</span>: path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'src'</span>, <span class="string">'libs'</span>),</span><br><span class="line">    <span class="string">'@assets'</span>: path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'src'</span>, <span class="string">'assets'</span>),</span><br><span class="line">    <span class="string">'@ant-design/icons/lib/dist$'</span>: path.resolve(__dirname, <span class="string">'../'</span>, <span class="string">'src'</span>, <span class="string">'icon.js'</span>),</span><br><span class="line">    <span class="string">'vue'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是改变这个打包路径 ‘@ant-design/icons/lib/dist$’</p>
<h3 id="icon-js的文件"><a href="#icon-js的文件" class="headerlink" title="icon.js的文件"></a>icon.js的文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CloseOutline</span><br><span class="line">&#125; from <span class="string">'@libs/components/icons/CloseOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CheckOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CheckOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as LoadingOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/LoadingOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CheckCircleOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CheckCircleOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as InfoCircleOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/InfoCircleOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CloseCircleOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CloseCircleOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as ExclamationCircleOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/ExclamationCircleOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CheckCircleFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/CheckCircleFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as InfoCircleFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/InfoCircleFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CloseCircleFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/CloseCircleFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as ExclamationCircleFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/ExclamationCircleFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123; default as UpOutline &#125; from <span class="string">'@ant-design/icons/lib/outline/UpOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as DownOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/DownOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as LeftOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/LeftOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as RightOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/RightOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as RedoOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/RedoOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CalendarOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CalendarOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as SearchOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/SearchOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as BarsOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/BarsOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as StarFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/StarFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as FilterOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/FilterOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CaretUpFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/CaretUpFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CaretDownFill</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/fill/CaretDownFill'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CaretUpOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CaretUpOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as CaretDownOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/CaretDownOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as PlusOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/PlusOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as FileOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/FileOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as FolderOpenOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/FolderOpenOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as FolderOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/FolderOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as PaperClipOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/PaperClipOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as PictureOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/PictureOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as EyeOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/EyeOutline'</span></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  default as DeleteOutline</span><br><span class="line">&#125; from <span class="string">'@ant-design/icons/lib/outline/DeleteOutline'</span></span><br></pre></td></tr></table></figure>
<p>就是将你需要更改的图标的地址改为你本地的<br>而且这里可以只引入一些你需要的图标，会减少一些icon库的打包大小</p>
<h3 id="本地的图标"><a href="#本地的图标" class="headerlink" title="本地的图标"></a>本地的图标</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"use strict"</span></span><br><span class="line">Object.defineProperty(exports, <span class="string">"__esModule"</span>, &#123; value: <span class="literal">true</span> &#125;)</span><br><span class="line">var CloseOutline = &#123;</span><br><span class="line">  name: <span class="string">'close'</span>,</span><br><span class="line">  theme: <span class="string">'outline'</span>,</span><br><span class="line">  icon: &#123;</span><br><span class="line">    tag: <span class="string">'svg'</span>,</span><br><span class="line">    attrs: &#123; version: <span class="string">'1.0'</span>, viewBox: <span class="string">'0 0 16 16'</span>, focusable: <span class="literal">false</span> &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        tag: <span class="string">'path'</span>,</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          <span class="string">'fill-rule'</span>: <span class="string">'evenodd'</span>,</span><br><span class="line">          d: <span class="string">'M10.17 7.72l5.63-5.67a.63.63 0 000-.9l-.86-.91a.63.63 0 00-.91 0L8.35 5.9a.42.42 0 01-.61 0L2.06.2a.63.63 0 00-.91 0l-.91.9a.63.63 0 000 .91l5.68 5.67c.17.17.17.43 0 .6L.2 13.98a.63.63 0 000 .92l.9.9c.27.26.66.26.92 0l5.68-5.66a.42.42 0 01.6 0l5.68 5.67c.26.25.65.25.91 0l.91-.91a.63.63 0 000-.91l-5.63-5.67a.42.42 0 010-.6'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">exports.default = CloseOutline</span><br></pre></td></tr></table></figure>
<p>使用ant-design-icons的库做转换<br><a href="https://github.com/ant-design/ant-design-icons" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-icons</a></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各有利弊,欢迎补充</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>写前端就是写表单？</title>
    <url>/2021/01/14/form/</url>
    <content><![CDATA[<p>首先，大家思考一下表单是什么？前端又是什么？<br><a id="more"></a></p>
<hr>
<h2 id="表单是什么？"><a href="#表单是什么？" class="headerlink" title="表单是什么？"></a>表单是什么？</h2><p>小弟不才，曾有幸参与<code>某中台的表单引擎</code>的开发工作，一般开发前我们都是先用<code>领域设计模型</code>分析一波，时间的关系，先上图<br><img src="/images/form/form.png" alt></p>
<p>用现在流行的<code>八卦文</code>翻译一下就是要先找出业务的聚合根，再分析它的属性，然后再总结它的生命周期<br>最后我们得出的结论是：<br>写前端<font size="24" color="red">不</font>等于写表单<br><strong>本文终。</strong><br><img src="/images/form/stop.jpeg" alt></p>
<h2 id="前端是什么？"><a href="#前端是什么？" class="headerlink" title="前端是什么？"></a>前端是什么？</h2><blockquote>
<p>那写前端到底是写什么？<br>本人才疏学浅<br>我认为人机需要交互的地方都属于前端<br>包括但不限于全息控制、人脑控制、声音控制、AR、VR<br>所以说要立志要做大前端的那位<br>你们以后的css样式可能还要加上声音/气味属性了</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flower</span>:&#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">  <span class="attribute">sound</span>: quiet;</span><br><span class="line">  <span class="attribute">smell</span>: sweet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="我设计的表单"><a href="#我设计的表单" class="headerlink" title="我设计的表单"></a>我设计的表单</h2><p>但相信大家都同意的是，表单开发在日常的开发中，应该是最复杂，占用的时间应该是最多的<br>我先来随便说几点：</p>
<ul>
<li>动态表单生成</li>
<li>多级联动</li>
<li>动态校验</li>
<li>定制业务组件</li>
<li>嵌套子级表单</li>
<li>数据反显</li>
<li>编辑状态禁用</li>
<li>等等</li>
</ul>
<p>某知名博文《写前端就是写表单？》的博主曾经说过：“控制最小边界，组合，就是好架构”<br>所以我们先设计一个最小的表单</p>
<h3 id="最小的表单"><a href="#最小的表单" class="headerlink" title="最小的表单"></a>最小的表单</h3><p>1.要有一个<code>&lt;form&gt;&lt;/form&gt;</code><br>2.要有一个<code>formData</code><br>3.要有一个<code>控件配置表</code></p>
<h3 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h3><blockquote>
<p>建一个form-register.ts 的文件</p>
</blockquote>
<p>ts, 是的我加了ts<br>就是将所有组件import进来 再export出去<br>规范点的话还能用require.context动态引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Text <span class="keyword">from</span> <span class="string">'./Text/index.vue'</span></span><br><span class="line"><span class="comment">//类型</span></span><br><span class="line"><span class="keyword">export</span>  formConfigs:formTypes= &#123;</span><br><span class="line">  text: Text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>眼利的朋友应该发现有一个formTypes</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件的class很强大，可以直接作为类型</span></span><br><span class="line"><span class="keyword">export</span> interface formTypes &#123;</span><br><span class="line">  Text?: Text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那还有一个最关键的别人调用的配置项是长怎样的呢，以下是我的参考，具体可以根据自己业务需要自行添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface fieldType &#123;</span><br><span class="line">  fieldType: keyof formTypes</span><br><span class="line">  key: string</span><br><span class="line">  dict?: string</span><br><span class="line">  type?: string</span><br><span class="line">  name?: string</span><br><span class="line">  label?: string</span><br><span class="line">  placeholder?: string</span><br><span class="line">  required?: boolean</span><br><span class="line">  isShow?: <span class="built_in">Function</span> <span class="comment">//是否显示</span></span><br><span class="line">  dateType?: <span class="string">'date'</span> | <span class="string">'time'</span> | <span class="string">'year-month'</span> | <span class="string">'month-day'</span> | <span class="string">'datetime'</span></span><br><span class="line">  readonly?: boolean</span><br><span class="line">  rules?: rule[]</span><br><span class="line">  isWrap?: boolean</span><br><span class="line">  hiddenLabel? :boolean</span><br><span class="line">  extraKey?: string | extraKeyType[]</span><br><span class="line">  formDataFormatter?: <span class="built_in">Function</span> <span class="comment">//格式化函数</span></span><br><span class="line">  formDataConvert?: <span class="built_in">Function</span> <span class="comment">// 转换成多个其他值</span></span><br><span class="line">  propShowValue?:string <span class="comment">//显示的字段</span></span><br><span class="line">  handleChange?: <span class="built_in">Function</span></span><br><span class="line">  [k: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家发现会有一个<code>[k: string]: any</code>，需然牺牲了一些类型约束，但是换来的扩展自由也是很有价值的</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote>
<p>加入了一个动态组件渲染</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;template v-<span class="keyword">for</span>=<span class="string">"fieldItem in fieldList"</span>&gt;</span><br><span class="line">    &lt;component</span><br><span class="line">      :key=<span class="string">"fieldItem.key"</span></span><br><span class="line">      :is=<span class="string">"formRegister[fieldItem.fieldType]"</span></span><br><span class="line">      :fieldItem=<span class="string">"fieldItem"</span></span><br><span class="line">      v-bind=<span class="string">"fieldItem"</span></span><br><span class="line">      v-model=<span class="string">"formData[fieldItem.key]"</span></span><br><span class="line">    &gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里用到<code>v-bind</code>把所有属性props进去，react的话可以自己解构<code>...props</code><br>到这里如无意外的话，你的表单组件应该渲染出来了<br>但有人可能就会问，也不是杠什么的，你的<code>fieldList</code>是怎样来的</p>
</blockquote>
<h3 id="函数生成器"><a href="#函数生成器" class="headerlink" title="函数生成器"></a>函数生成器</h3><p>当初设计的时候第一直觉，就是props一个<code>fieldList</code>的数组进来<br>但后来遇到一些问题</p>
<ul>
<li>组件之间联动</li>
<li>数据值强绑定</li>
<li>表单项动态生成</li>
<li>校验规则条件动态变化</li>
<li>等<br>可能都要监听<code>formData</code>值的变化，再改变<code>fieldList</code>的值</li>
</ul>
<blockquote>
<p>后来，某天发呆的时候，想到《上帝掷骰子吗》一书中，对多宇宙的一个解说是，<code>每个世界线的变动都会再产生出一个新宇宙</code></p>
</blockquote>
<p>好家伙，那我们为什么不能写一个多宇宙的表单组件呢？<code>每次formData值的变动就再产生出一个新的fieldList</code><br><strong>fieldListMaker诞生</strong><br>我马上改成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> formDataString() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.formData)</span><br><span class="line">&#125;</span><br><span class="line">@Watch(<span class="string">'formDataString'</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">formDataChanged(val: any, <span class="attr">oldVal</span>: any) &#123;</span><br><span class="line">  <span class="keyword">if</span> (val !== oldVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fieldList = <span class="keyword">this</span>.fieldListMaker(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>formData转为string监听，为了避免一些深层次的属性变化监听不到<br>传入的时候fieldListMaker长这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fieldListMaker(formData: any): <span class="built_in">Array</span>&lt;fieldType&gt; &#123;</span><br><span class="line">  <span class="comment">// 你在这里可以做你想做的各种东西😊</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      fieldType: <span class="string">'text'</span>,</span><br><span class="line">      key: <span class="string">'abc'</span>,</span><br><span class="line">      label: <span class="string">'def'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际使用就是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FormList <span class="keyword">from</span> <span class="string">'@/components/form/index.vue'</span></span><br><span class="line">&lt;FormList</span><br><span class="line">  ref=<span class="string">"formRef"</span></span><br><span class="line">  :fieldListMaker=<span class="string">"fieldListMaker"</span></span><br><span class="line">  :showBtn=<span class="string">"false"</span></span><br><span class="line">  @change=<span class="string">"handleFormChange"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>大家可以根据各自喜好，在里面添加一些方法，如：</p>
<ol>
<li>校验方法</li>
<li>设置属性值方法</li>
<li>清空校验方法</li>
<li>强制更新list方法</li>
<li>等<br>各种业务表单组件也可以自己添加，只要约定好一些基本方法，里面@Model(‘change’)出来一个双向绑定就好了<br><strong>真.完结,撒花</strong></li>
</ol>
<blockquote>
<p>彩蛋</p>
</blockquote>
<p>有兴趣的可以看源代码<a href="https://github.com/hundren/multiverse-form" title="代码地址" target="_blank" rel="noopener">多宇宙表单</a></p>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>1.10乘100为什么不等于110</title>
    <url>/2017/02/14/js-note/</url>
    <content><![CDATA[<h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><p>要从今天的微信支付调试说起，众所周知微信支付的接口，要求传入的金额数值是按分为单位的，所以都必须是大于0的整数。<br><a id="more"></a><br>&emsp;&emsp;所以我们一般业务的实际金额都要做乘以100的处理，例如某大妈刚在市场买了1.10元的菜，她摸了摸口袋，看了一眼诚实憨厚的大叔，已经麻利地帮她打包好菜，实在不忍心说出自己今天忘记带钱包。<br>&emsp;&emsp;大叔正打算把菜递给大妈之际，看到大妈尾头紧皱，已经失去平时要把1.10元的菜讲价到1.00元的风韵神采，便意识到事情并不简单，便默默从下方抽屉中抽出一个微信二维码递给她。<br>&emsp;&emsp;大妈心中暗喜，迅速拔出他儿子刚为她买的最新款红米手机，熟练地扫过二维码，也没有要讲价到1.00元的意思了，麻利地在微信上输入1.10元的金额，点击立即支付，输入过密码。。。<br>&emsp;&emsp;“参数错误：你输入的金额格式不正确”，看着手机弹出的提示弹窗，大妈狠狠咬了牙，又重复了一遍上述的支付动作，“参数错误：你输入的金额格式不正确”。这时大妈崩溃的用着恳求可怜的眼神看着大叔，大叔也一面无奈地轻轻将打包好的菜微微收了过来一下，空气突然安静地凝固起来。</p>
<h2 id="问题剖释"><a href="#问题剖释" class="headerlink" title="问题剖释"></a>问题剖释</h2><p>&emsp;&emsp;空中传来旁白君的声音，它解析道：<br>&emsp;&emsp;没错，这为大妈所使用的程序，其实就是某知名博文《1.10乘100为什么不等于110》的博主还未调试完之前写的代码。<br>&emsp;&emsp;他就是这样把金额1.10乘100然后传过去微信的支付接口，他是那样的信心满满，因为他之前含着泪用自己的微信零钱支付的测试都是那样一条条地测试成功。他一次次发起1.10元支付测试，看着一次次弹出的反馈信息“参数错误：你输入的金额格式不正确”，他越觉得莫名奇妙，1.10乘100不就等于110吗，还有什么格式错误的？然而当这个too young too naive的少年，找出这个输入结果后，空气又突然安静地凝固起来。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;1.10*100</span><br><span class="line">110.00000000000001</span><br></pre></td></tr></table></figure></p>
<p>WHAT THE *!</p>
<h2 id="IEEE754-双精度浮点数"><a href="#IEEE754-双精度浮点数" class="headerlink" title="IEEE754 双精度浮点数"></a>IEEE754 双精度浮点数</h2><p>Javascript 作为一门动态语言，其数字类型只有 number 一种。 nubmer 类型使用的就是美国电气电子工程师学会 IEEE754 标准中以64-bit存储的的双精度浮点。<br>而浮点数表示方式具有以下特点：<br>1.浮点数可表示的值范围比同等位数的整数表示方式的值范围要大得多；</p>
<p>2.浮点数无法精确表示其值范围内的所有数值，而有符号和无符号整数则是精确表示其值范围内的每个数值；</p>
<p>3.浮点数只能精确表示m*2e的数值；</p>
<p>4.当biased-exponent为2e-1-1时，浮点数能精确表示该范围内的各整数值；</p>
<p>5.当biased-exponent不为2e-1-1时，浮点数不能精确表示该范围内的各整数值。</p>
<p>由于部分数值无法精确表示（存储），于是在运算统计后偏差会愈见明显。</p>
<h3 id="So-Why-1-10-100-110-00000000000001"><a href="#So-Why-1-10-100-110-00000000000001" class="headerlink" title="So Why 1.10 * 100 === 110.00000000000001?"></a>So Why 1.10 * 100 === 110.00000000000001?</h3><p>1.1.10实际存储时的位模式是：<br>0011111111110001100110011001100110011001100110011001100110011001;<br>2.100实际存储时的位模式是<br>0110010000000000000000000000000000000000000000000000000000000000;<br>3.实际存储的位模式作为操作数进行浮点数乘法:<br>110000110011100010111011110111100110100001100000000000000。<br>转换为十进制即为110.00000000000001。</p>
<h3 id="0-1-0-2"><a href="#0-1-0-2" class="headerlink" title="0.1+0.2"></a>0.1+0.2</h3><p>其实这和那著名的 0.1 + 0.2 === 0.30000000000000004问题是一个道理的，可笑的是，只要我们的大妈把价讲到1.00元<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;1.00*100</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p>就不会有问题了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS坑常有，我们慢慢填之。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>JS填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>面试经历</title>
    <url>/2021/08/15/interview/</url>
    <content><![CDATA[<p>分享一下一些面试经历</p>
<hr>
<h2 id="腾讯-小游戏部门"><a href="#腾讯-小游戏部门" class="headerlink" title="腾讯-小游戏部门"></a>腾讯-小游戏部门</h2><p>笔试题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一组图片链接，加载全部图片</span></span><br><span class="line"><span class="comment"> * @param &#123;String[]&#125; imgList 图片链接数组</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAllImages</span>(<span class="params">imgList</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadOneImage</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">               </span><br><span class="line"><span class="keyword">const</span> imgList = [</span><br><span class="line">  <span class="string">'https://www.midea.com/1.png'</span>,</span><br><span class="line">  <span class="string">'https://www.midea.com/2.png'</span>,</span><br><span class="line">  <span class="string">'https://www.midea.com/3.png'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预期: imgList包含的全部图片链接加载成功后执行回调</span></span><br><span class="line">loadAllImages(imgList).then(<span class="function">(<span class="params">imgs</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'loadAllImages success'</span>, imgs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>怎样将html、css转换成canvas</li>
<li>有没做过小游戏</li>
<li>img的onLoad怎样回调</li>
<li>reactNative 转换成app的原理</li>
<li>项目上的问题</li>
<li>为什么要用mpvue</li>
</ul>
<h2 id="腾讯-质控部门"><a href="#腾讯-质控部门" class="headerlink" title="腾讯-质控部门"></a>腾讯-质控部门</h2><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">aaaabbbccccddfgh  给定一个字符串,写一个函数输出数量最多，相同的也要输出</span><br></pre></td></tr></table></figure>
<ul>
<li>忘记问了什么了</li>
</ul>
<h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="编程题目"><a href="#编程题目" class="headerlink" title="编程题目"></a>编程题目</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* 合并排序</span><br><span class="line">* 写个方法把&lt;div a=<span class="string">"111"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;转换成对象</span></span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>xhr攻击</li>
<li>Https安全</li>
<li>微前端怎样做样式隔离</li>
<li>说说项目上那个很厉害的领域设计模型</li>
<li>websocket 原理</li>
</ul>
<h2 id="欢聚"><a href="#欢聚" class="headerlink" title="欢聚"></a>欢聚</h2><p>题目1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolve(<span class="number">7</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">8</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>题目2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.splice()</span><br><span class="line">arr.reverse()</span><br><span class="line">arr.slice()</span><br><span class="line">arr.map()</span><br><span class="line">哪些会造成数组原结构改变</span><br></pre></td></tr></table></figure>
<ul>
<li>输入url整个过程</li>
<li>说说跨域</li>
<li>协议、域名、端口哪些会造成跨域</li>
<li>浏览器缓存</li>
<li>301 是什么</li>
<li>cookie跨域获取</li>
<li>vue的mixins的顺序，mixins，page和子组件</li>
<li>created生命周期获取dom</li>
<li>说说事件循环</li>
<li>说说TCP的3次握手，第2次中断了会怎样</li>
<li>指令有什么生命周期</li>
</ul>
<h2 id="树根"><a href="#树根" class="headerlink" title="树根"></a>树根</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayToEcho</span> (<span class="params">msg, cb</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="built_in">Date</span>.now() % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    cb(err, msg);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常调用</span></span><br><span class="line">delayToEcho(<span class="string">'msg'</span>, (err, msg) =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">msg</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 请把这个函数实现，能够让第 #15 行开始的代码能够成功运行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      fn(msg,(err,msg)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          resolve(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log('promisify',promisify(delayToEcho)('dddd'))</span></span><br><span class="line">promisify(delayToEcho)(<span class="string">'msg'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'msg'</span>,msg);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'err'</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>样式居中</li>
<li>new方法</li>
<li>react 的hooks有哪些</li>
<li>箭头函数特点</li>
</ul>
<h2 id="碧桂园"><a href="#碧桂园" class="headerlink" title="碧桂园"></a>碧桂园</h2><ul>
<li>浏览器缓存</li>
<li>vue的diff</li>
<li>object对象有哪些不能枚举</li>
<li>说说es6数组的新api</li>
</ul>
<h2 id="欢聚shopeline"><a href="#欢聚shopeline" class="headerlink" title="欢聚shopeline"></a>欢聚shopeline</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul>
<li>浏览器的性能瓶颈</li>
<li>webpack的dll缓存你们的更新机制</li>
<li>umi的不好的地方</li>
<li>vue和react不同的性能优化方法</li>
<li>一个main.js包和多个小包的各自的好处</li>
<li>cdn缓存的方法、页面数据缓存</li>
<li>vue的渲染生命周期</li>
<li>ci/cd的实现</li>
<li>组件库的设计</li>
<li>ts的使用情况</li>
<li>vue2对ts的支持</li>
<li>有什么项目比较有痛点</li>
<li>有没做过ssr</li>
<li>飞冰和umi的区别</li>
<li>react的jsx怎样转换成页面</li>
</ul>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul>
<li>webpack5的联邦绑定</li>
<li>微前端怎样渲染那个url</li>
<li>nodejs多线程怎样通信</li>
<li>nodejs中间件怎样数据共享</li>
<li>websocket突然收到多个并发怎样处理</li>
<li>nodejs的global是什么</li>
</ul>
<h2 id="YY"><a href="#YY" class="headerlink" title="YY"></a>YY</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ul>
<li>树的最大权重路径问题（随机权重）</li>
<li>cookie跨域设置</li>
<li>防御dns攻击</li>
<li>ssr怎样知道html和数据返回了</li>
<li>前端负责人和一线技术</li>
<li>聊聊微前端</li>
<li>Https为什么可以防止dns攻击</li>
<li>nodejs的内存泄漏定位</li>
<li>写个左右布局的样式，头像固定</li>
<li>vue 和 react 的对比</li>
<li>react Native 的写法</li>
</ul>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul>
<li>我想发一个跨域，header需要怎样配置（Access-Control-Allow-Origin:*）</li>
<li>webpack5有什么新特性</li>
<li>webpack5的tree shaking和webpack4有什么区别</li>
<li>有没有了解过server worker</li>
<li>有没有了解过webworker，用在什么地方</li>
<li>webgl基于什么实现</li>
<li>说说vue的路由原理，hash和history分别用到什么api</li>
<li>computed是个独立的沙箱，说说vuex怎么会被computed监听到</li>
<li>canvas怎样读取图片，怎样获取canvas图片后的色值，上传到服务器用什么办法</li>
<li>如何控制canvas动画的快慢</li>
<li>ci/cd 的实现，docker机制</li>
<li>让你用c语言自己实现一个数组的push要怎样写</li>
<li>微前端的原理</li>
<li>webassembly有没了解过，他最终浏览器是会转成什么</li>
<li>nodejs 的守护进程用什么，他们的原理是怎样的</li>
<li>开发nodejs的时候是怎样部署到服务器的</li>
<li>websocket的底层原理，最大并发是多少，服务器怎样限制这个最大并发数</li>
<li>说说v8的堆和栈，（基础类型和引用类型，基本类型栈，引用堆）</li>
<li>为什么考虑到用RN</li>
<li>进程和线程的区别</li>
<li>移动端自适应方案</li>
<li>微前端怎样通过url渲染</li>
</ul>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul>
<li>webpack5的模块联邦有没了解过</li>
<li>用领域设计模式对开发有什么好处</li>
<li>微前端有没使用过</li>
<li>Handlebars有没使用过，模板语法有什么好处</li>
</ul>
<h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ul>
<li>新技术会怎样落地</li>
<li>怎样看待996</li>
<li>有没用过YY什么产品</li>
<li>怎样接触一些新的技术</li>
</ul>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的变量提升了解一下？</title>
    <url>/2018/03/14/js-var/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var 100</span><br><span class="line">//等等，去喝杯咖啡再写</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>JS填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript设计模式》很有感</title>
    <url>/2017/06/14/javascript-model/</url>
    <content><![CDATA[<p>之前总听到设计模式很重要,于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事串起了一整本书，（定义一般都比较晦涩难懂，可以先看看使用场景再回来理解相关定义）<br><a id="more"></a><br>先给个书的链接: <a href="https://www.amazon.cn/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%A0%E5%AE%B9%E9%93%AD/dp/B013HO6DNS/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1482324196&amp;sr=1-2&amp;keywords=javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">JavaScript设计模式-张容铭</a></p>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等。设计模式主要分为三大类型，创建型模式，结构型模式和行为型模式，本书还额外写了另两类设计模式，技巧型模式和架构型模式。JavaScript设计模式是以面向对象编程为基础的，JavaScript的面向对象编程和传统的C++、Java的面向对象编程有些差别，这让我一开始接触JavaScript的时候感到十分痛苦，但是这只能靠自己慢慢积累慢慢思考。想继续了解JavaScript设计模式必须要先搞懂JavaScript面向对象编程，否则只会让你自己更痛苦。</p>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。创建型设计模式主要有简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式和单例模式，下面一一道来。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>作者把简单工厂模式比喻成一个神奇的魔术师。</p>
<p>定义</p>
<p>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>
<p>使用场景</p>
<p>看完上面的定义一定很不解，说的到底是啥，现在就举个例子来解释一下。比如体育商品店卖体育器材，里面有很多体育用品及其相关介绍。当你来到体育用品店买一个篮球，只需问售货员，他就会帮你找到你所要的东西。用程序实现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 篮球基类</span><br><span class="line">var Basketball = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.intro = <span class="string">'篮球盛行于美国'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Basketball.prototype = &#123;</span><br><span class="line">    getMember: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'每个队伍需要5名队员'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getBallSize: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'篮球很大'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 足球基类</span><br><span class="line">var Football = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.intro = <span class="string">'足球盛行于美国'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Football.prototype = &#123;</span><br><span class="line">    getMember: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'每个队伍需要11名队员'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getBallSize: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'篮球很大'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 运动工厂</span><br><span class="line">var SportsFactory = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    switch(name) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'NBA'</span>: </span><br><span class="line">            <span class="built_in">return</span> new Basketball();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'wordCup'</span>: </span><br><span class="line">            <span class="built_in">return</span> new Football();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你使用这个运动工厂时只需要记住SportsFactory这个工厂对象就好了，它会帮你找到你想要的。<br>简单工厂模式的理念是创建对象，上面例子是将不同的类实例化，但是简单工厂模式还可以创建相似对象，将相似的东西提取，不相似的针对性处理即可。这样只需创建一个对象就可以替代多个类了。</p>
<p>收获与总结</p>
<p>团队开发不同于个人，对全局变量的限制很大，要尽量少得创建全局变量。如果有同一类对象在不同需求中重复使用，那么大部分是不需要重复创建的，要学会代码复用。用简单工厂来创建对象，可以减少全局变量创建提高代码复用率，它的使用场合限制在创建单一对象。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>作者把工厂方法模式比喻成一张名片。</p>
<p>定义</p>
<p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>
<p>使用场景</p>
<p>在实际开发中，需求的变更是很正常的，开始需求简单可以直接创建对象，类似的需求多了可以用简单工厂方法重构，但是如果需求不停变化，那么不仅要修改工厂函数还要添加类，这样就没完了。而工厂方法模式本意是将实际创建对象的工作推迟到子类中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 工厂类</span><br><span class="line">var Factory = <span class="keyword">function</span>(<span class="built_in">type</span>, content) &#123;</span><br><span class="line">    <span class="keyword">if</span>(this instanceof Factory) &#123;</span><br><span class="line">        var s = new this[<span class="built_in">type</span>](content);</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 防止使用者不知道这是一个类，忘了加new操作符创建，导致全局变量污染</span><br><span class="line">        <span class="built_in">return</span> new Factory(<span class="built_in">type</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    Java: <span class="keyword">function</span>(content) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    JavaScript: <span class="keyword">function</span>(content) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    php: <span class="keyword">function</span>(content) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样以后如果想添加其他类，只需要在Factory的原型里添加就可以了。</p>
<p>收获与总结</p>
<p>对于创建很多类的对象，简单工厂模式就不适合了，通过工厂模式可以轻松创建多个类的实例对象，而且避免了使用者与对象类之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式让你感觉出现的都是幻觉。</p>
<p>定义</p>
<p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责某一类产品的实例。</p>
<p>抽象类</p>
<p>抽象类是一种声明但不能使用的类，当你使用的时候就会报错。JavaScript中的抽象类不能像传统面向对象语言那样轻松地创建，我们可以在类的方法中手动抛出错误来模拟抽象类。你可能会想，这样的类什么都不能做能有什么用？其实它在继承上是很有用的。</p>
<p>使用场景</p>
<p>抽象工厂模式不能用来创建具体对象，一般用它作为父类类创建一些子类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 抽象工厂方法</span><br><span class="line">var VehicleFactory = <span class="keyword">function</span>(subType, superType) &#123;</span><br><span class="line">    // 判断抽象工厂中是否有该抽象类</span><br><span class="line">    <span class="keyword">if</span>(typeof VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        // 缓存类</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;;</span><br><span class="line">        // 继承父类属性和方法</span><br><span class="line">        F.prototype = new VehicleFactory[superType]();</span><br><span class="line">        // 将子类构造函数指向子类</span><br><span class="line">        subType.constructor = subType;</span><br><span class="line">        // 子类原型继承父类</span><br><span class="line">        subType.prototype = new F();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不存在该抽象类抛出错误</span><br><span class="line">        throw new Error(<span class="string">'未创建该抽象类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 小汽车抽象类</span><br><span class="line">VehicleFactory.Car = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'car'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 公交车抽象类</span><br><span class="line">VehicleFactory.Bus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.type = <span class="string">'bus'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">VehicleFactory.Bus.prototype = &#123;</span><br><span class="line">    getPrice: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new Error(<span class="string">'抽象方法不能调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抽象工厂实际上是一个子类继承父类的方法，在该方法中需要通过传递子类以及继承父类的名称。</p>
<p>收获与总结</p>
<p>抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式。该模式创建出的结果不是一个真实的对象实例，而是一个类簇，指定了类的结构。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式告诉我们分即是合。</p>
<p>定义</p>
<p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>
<p>应用场景</p>
<p>现在有一个发布简历的需求，就是帮别人在公司网站上发布简历，但是这些简历有一个需求，除了将兴趣爱好以及一些特长发布在页面里，其他信息如联系方式等不要发布在网站上，而且每个人想找的工作是可以分类的。这样一些需求我们需要创建的东西就多了，这时候前面的三种工厂模式都不适合了，这里就可以用建造者模式。<br>建造者模式和只关心创建结果的工厂模式不同，虽然其目的也是创建一个对象，但是更多关心的是创建这个对象的整个过程。在本例中，我们需要的不仅仅是应聘者的实例还要在创建过程中注意这位应聘者有哪些兴趣爱好等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 创建一位人类</span><br><span class="line">var Human = <span class="keyword">function</span>(param) &#123;</span><br><span class="line">    // 技能</span><br><span class="line">    this.skill = param &amp;&amp; param.skill || <span class="string">'保密'</span>;</span><br><span class="line">    // 兴趣爱好</span><br><span class="line">    this.hobby = param &amp;&amp; param.hobby || <span class="string">'保密'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">// 类人原型方法</span><br><span class="line">Human.prototype = &#123;</span><br><span class="line">    getSkill: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this.skill;</span><br><span class="line">    &#125;,</span><br><span class="line">    getHobby: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this.hobby;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 实例化姓名类</span><br><span class="line">var Named = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    // 构造器，解析姓名的姓与名</span><br><span class="line">    (<span class="keyword">function</span>(name, that) &#123;</span><br><span class="line">        that.wholeName = name;</span><br><span class="line">        <span class="keyword">if</span>(name.indexOf(<span class="string">' '</span>) &gt; -1) &#123;</span><br><span class="line">            that.FirstName = name.slice(0, name.indexOf(<span class="string">' '</span>));</span><br><span class="line">            that.FirstName = name.slice(name.indexOf(<span class="string">' '</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(name, that);</span><br><span class="line">&#125;;</span><br><span class="line">// 实例化职位类</span><br><span class="line">var Work = <span class="keyword">function</span>(work) &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    // 构造器，通过传入的职位特征来设置相应职位及描述</span><br><span class="line">    (<span class="keyword">function</span>(work, that) &#123;</span><br><span class="line">        switch(work) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'code'</span>:</span><br><span class="line">                that.work = <span class="string">'工程师'</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'UI'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'UE'</span>:</span><br><span class="line">                that.work = <span class="string">'设计师'</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'teach'</span>:</span><br><span class="line">                that.work = <span class="string">'教师'</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                that.work = work;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(work, that);</span><br><span class="line">&#125;;</span><br><span class="line">// 更换期望的职位</span><br><span class="line">Work.prototype.changeWork = <span class="keyword">function</span>(work) &#123;</span><br><span class="line">    this.work = work;</span><br></pre></td></tr></table></figure>
<p>下面来创建一位应聘者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 应聘者创建类</span><br><span class="line">var Person = <span class="keyword">function</span>(name, work) &#123;</span><br><span class="line">    // 创建应聘者缓存对象</span><br><span class="line">    var _person = new Human();</span><br><span class="line">    // 创建应聘者姓名解析对象</span><br><span class="line">    _person.name = new Named(name);</span><br><span class="line">    // 创建应聘者期望职位</span><br><span class="line">    _person.work = new Work(work);</span><br><span class="line">    // 返回创建的应聘者对象</span><br><span class="line">    <span class="built_in">return</span> _person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>建造者模式和前面几种创建型设计模式不同，它关心对象的整个创建过程，因此通常将创建对象的类模块化，这样使创建类的每一个模块都可以得到灵活的运用与高质量的复用。这种方式对于整个对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低，不建议使用建造者模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是JavaScript语言之魂。</p>
<p>定义</p>
<p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>
<p>使用场景</p>
<p>还是关于子类继承父类的问题，为了提高性能，对于每次创建的一些简单的而又有差异化的属性可以放在构造函数中，将一些消耗资源比较大的方法放在基类的原型中，这样就可以避免不必要的消耗，这就是原型模式的雏形。<br>原型模式更多的是用在对象的创建上，比如创建一个实例对象的构造函数比较复杂或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，可以通过对这些对象属性或者方法进行复制来实现创建。首先要有一个原型对象的复制方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 原型对象复制方法</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">prototypeExtend</span></span>() &#123;</span><br><span class="line">    var F = <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        args = arguments,</span><br><span class="line">        i = 0,</span><br><span class="line">        len = args.length;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        // 遍历每个模板对象中的属性</span><br><span class="line">        <span class="keyword">for</span>(var j <span class="keyword">in</span> args[i]) &#123;</span><br><span class="line">            F.prototype[j] = args[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回缓存类实例</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>企鹅游戏中创建一个企鹅对象，如果没有企鹅基类，只提供了一些动作模板对象，可以通过实现这些模板对象的继承来创建一个企鹅实例对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var penguin = prototypeExtend(&#123;</span><br><span class="line">    speed: 20,</span><br><span class="line">    swim: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'游泳速度'</span> + this.speed);</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'奔跑速度'</span> + this.speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样通过prototypeExtend创建的就是一个对象，不用再用new去创建一个新的实例对象。</p>
<p>收获与总结</p>
<p>原型模式实际上也是一种继承，可以让多个对象分享同一个原型对象的属性和方法，这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象。原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>哈哈，让你感受下一个人的寂寞。</p>
<p>定义</p>
<p>又被称为单体模式，只允许实例化一次的对象类。有时也可以用一个对象来规划一个命名空间，井井有条地管理对象上的属性和方法。</p>
<p>使用场景</p>
<p>单例模式应该是JavaScript中最常见的一种设计模式了，经常为我们提供一个命名空间，来防止不同的人命名变量的冲突。还可以用它来创建一个小型的代码库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line">    Util: &#123;</span><br><span class="line">        util_method1: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        util_method2: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Tool: &#123;</span><br><span class="line">        tool_method1: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        tool_method2: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Ajax: &#123;</span><br><span class="line">        ajax_method1: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        ajax_method2: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想使用这个代码库，像下面这样访问即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A.Util.util_method1();</span><br><span class="line">A.Tool.tool_method2();</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>单例模式有时也被称为单体模式，它是只允许实例化一次的对象类，有时这么做也是为了节省系统资源。JavaScript中单例模式经常作为命名空间对象来实现，通过单例对象，我们可以将各个模块的代码井井有条地梳理在一起。</p>
<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计。主要有外观模式，适配器模式，代理模式，装饰者模式，桥接模式，组合模式和享元模式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>作者把这种模式比喻成一种套餐服务。</p>
<p>定义</p>
<p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>
<p>使用场景</p>
<p>为页面文档document对象添加点击事件时，如果直接用onclick来绑定事件，那么如果团队中再有人要为document绑定click事件时，就会把之前绑定的那个时间覆盖，因为这是DOM0级事件。我们应该用DOM2级事件处理程序提供的addEventListener来实现，然而老版本IE是不支持这个方法的，必须用attachEvent，这样如果我们写一个能兼容所有浏览器的方式操作起来就会更方便，这时候就可以用到外观模式。为功能统一但方法不统一的接口提供一个统一的接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 外观模式实现</span><br><span class="line"><span class="keyword">function</span> addEvent(dom, <span class="built_in">type</span>, fn) &#123;</span><br><span class="line">    // 对于支持DOM2级事件处理程序的浏览器</span><br><span class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</span><br><span class="line">        dom.addEventListener(<span class="built_in">type</span>, fn, <span class="literal">false</span>);</span><br><span class="line">    // 对于不支持addEventListener但支持attachEvent的浏览器</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</span><br><span class="line">        dom.attachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dom[<span class="string">'on'</span> + <span class="built_in">type</span>] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决浏览器兼容问题只是外观模式应用的一部分，很多代码库中都是通过外观模式来封装多个功能，简化底层造作方法的。</p>
<p>收获与总结</p>
<p>当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>听到这个模式的名字，有没有想到水管弯弯的场景呢？</p>
<p>定义</p>
<p>将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>
<p>使用场景</p>
<p>公司有个活动页面正在使用公司内部开发的A框架，可是很多新来的同事使用A框架开发新的功能需求时总是感觉很吃力，而且能用的方法有限，为了让新同事尽快融入项目的开发，可以引入jQuery框架，由于A框架和jQuery框架很像，这样就可以写一个适配器而不需要将之前的代码全用jQuery写一遍。<br>适配器模式不仅在编程中很常见，在生活中这种模式也很常见，比如三角插头充电器对于两项插头是不能用的，此时就需要一个三项转两项插头电源适配器，这就是一种适配器模式，其实它就是为了两个代码库所写的代码兼容运行而书写的额外代码。<br>JavaScript中适配器模式还能适配两个代码库，适配参数，适配数据，适配服务端数据等。以参数适配为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> doSomeThing(name, title, age, color, size, prize)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>记住这些参数的顺序是很困难的，所以我们经常是以一个参数对象方式传入的，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * obj.name: name</span><br><span class="line"> * obj.title: title</span><br><span class="line"> * obj.age: age</span><br><span class="line"> * obj.color: color</span><br><span class="line"> * obj.size: size</span><br><span class="line"> * obj.prize: prize</span><br><span class="line">***/</span><br><span class="line"><span class="keyword">function</span> doSomeThing(obj)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然而当调用的时候也不能确定传递的参数是否完整，如有一些必须得参数没有传入，一些参数有默认值等，这个时候就可以用适配器来适配传入的参数对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> doSomeThing(obj) &#123;</span><br><span class="line">    var _adapter = &#123;</span><br><span class="line">        name: <span class="string">'雨夜清荷'</span>,</span><br><span class="line">        title: <span class="string">'设计模式'</span>,</span><br><span class="line">        age: 24,</span><br><span class="line">        color: <span class="string">'pink'</span>,</span><br><span class="line">        size: 100,</span><br><span class="line">        prize: 50</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(var i <span class="keyword">in</span> _adapter) &#123;</span><br><span class="line">        _adapter[i] = obj[i] || _adapter[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>JavaScript中的适配器更多应用在对象之间，为了使对象可用，通常会将对象拆分并重新包装，这样就要了解适配器对象的内部结构，这也是与外观模式的区别所在。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>有没有想到牛郎织女鹊桥相会的场景？</p>
<p>定义</p>
<p>由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。</p>
<p>使用场景</p>
<p>跨域问题应该是使用代理模式解决的一个最典型的问题。由于用户模块上传的照片量越来越大，导致服务器需要将上传模块重新部署到另外一个域中，这就导致了跨域问题。我们可以将相册页面和上传模块所在的服务器抽象成两个对象，想让跨域两端的对象之间实现通信，就需要找个代理对象来实现他们之间的通信。<br>代理对象有很多种，简单一点的如img之类的标签通过src可以向其他域下的服务器发送请求。不过这类请求是get请求，是单向的，不会有响应数据。另外一种代理对象的形式是通过script标签。而我们需要的代理对象，是对页面与浏览器间通信的，JSONP就实现了一种代理模式。我们知道src属性可以实现get请求，因此可以在src指向的url地址上添加一些字段信息，服务器获取这些字段信息，相应生成一分内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 前端浏览器页面</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 回调函数</span><br><span class="line"><span class="keyword">function</span> jsonpCallBack(res,req) &#123;</span><br><span class="line">    console.log(res,req);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"http://localhost/test/jsonp.php?callback=jsonp CallBack&amp;data=getJsonPData"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 另一个域下的服务器请求接口</span><br><span class="line">&lt;?php</span><br><span class="line">/* 后端获取请求字段数据，并生成返回内容 */</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$_GET</span>[<span class="string">"data"</span>];</span><br><span class="line"><span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">"callback"</span>];</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$callback</span>.<span class="string">"('success', '"</span>.<span class="variable">$data</span>.<span class="string">"')"</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式可以想象成合理的一只小船，通过小船将你的请求发送给对岸，然后对岸的人们将数据放在小船里为你带回来。</p>
<p>收获与总结</p>
<p>代理模式除了在跨域问题中有很多应用外，有时对对象的实例化对资源的开销很大，如页面加载初期加载文件有很多，此时能够延迟加载一些图片对页面首屏加载时间收益是很大的，通过代理可以先加载预览图片然后再加载开销大的图片。<br>由此可见，代理模式可以解决系统之间耦合度以及系统资源开销大的问题，通过代理对象可以保护被代理对象，使被代理对象不受外界的影响。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>显然房子装修就是一种典型的装饰者模式。</p>
<p>定义</p>
<p>在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>
<p>使用场景</p>
<p>静止是相对的，运动是绝对的，所以没有一成不变的需求。在实际项目开发中需求总在不断变化，当原有的功能已经不能满足用户的需求时，我们要做的就是在这个基础上添砖加瓦，设置新功能和属性来满足用户提出的需求，这就是装饰者模式要做的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 装饰者</span><br><span class="line">var decorator = <span class="keyword">function</span>(input, fn) &#123;</span><br><span class="line">    // 获取事件源</span><br><span class="line">    var input = document.getElementById(input);</span><br><span class="line">    // 若事件源已经绑定事件</span><br><span class="line">    <span class="keyword">if</span>(typeof input.onclick === <span class="string">'function'</span>) &#123;</span><br><span class="line">        // 缓存事件源原有回调函数</span><br><span class="line">        var oldClickFn = input.onclick;</span><br><span class="line">        // 为事件源定义新的事件</span><br><span class="line">        input.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            // 事件源原有回调函数</span><br><span class="line">            oldClickFn();</span><br><span class="line">            // 执行事件源新增回调函数</span><br><span class="line">            fn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        input.onclick = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>除了装饰者模式，适配器模式也可以对原有对象进行扩展，所不同的是适配器进行扩展很多时候是对对象内部结构的重组，因此了解其自身结构是必须的。而装饰者模式对对象的扩展是一种良性扩展，不用了解其具体实现，只是在外部进行了一次封装扩展。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>作者把这种模式比喻成城市间的公路。</p>
<p>定义</p>
<p>在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>
<p>使用场景</p>
<p>有时候，页面中一些小小细节的改变常常因逻辑相似而导致大片臃肿的代码，让页面苦涩不堪。现在项目有一个需求，是要把页面上部的用户信息添加一些鼠标划过的特效，但是用户信息由很多小组件组成，对于用户名，鼠标划过直接改变背景色，但是像用户等级、用户消息这类部件只能改变里面的数字内容，处理逻辑不太一样。这样就需要写不少代码，但是又会感觉很冗余。这时候，我们首先要提取共同点，对想的抽象逻辑做抽象提取处理。<br>对于用户信息模块的每一部分鼠标滑过与鼠标离开两个事件的执行函数有很大一部分是相似的，比如它们都处理每个部件中的某个元素，它们都是处理元素的字体颜色和背景颜色。可以创建下面这样一个函数，解除this耦合。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> changeColor(dom, color, <span class="built_in">bg</span>) &#123;</span><br><span class="line">    // 设置元素的字体颜色</span><br><span class="line">    dom.style.color = color;</span><br><span class="line">    // 设置元素的背景颜色</span><br><span class="line">    dom.style.background = <span class="built_in">bg</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>接下来就是对具体元素绑定事件了，但是仅仅知道元素事件绑定与抽象提取的设置样式方法changeColor是不够的，需要用一个方法将他们链接起来，这个方法就是桥接方法，这种模式就是桥接模式。就像你开着车去沈阳，那么你就需要找到一条连接北京与沈阳的公路，才能顺利往返两地。<br>对于事件的桥接方法，可以用一个匿名函数来代替。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var spans = document.getElementsByTagName(<span class="string">'span'</span>);</span><br><span class="line">spans[0].onmouseover = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    changeColor(this, <span class="string">'red'</span>, <span class="string">'#ddd'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>桥接模式最主要的特点是将实现层（如元素绑定事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，桥接模式主要是对结构之间的解耦。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>作者把组合模式比喻成超值午餐，感觉很形象。</p>
<p>定义</p>
<p>又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层级结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>使用场景</p>
<p>为强化首页用户体验，项目经理准备在用户首页添加一个新闻模块，当然新闻的内容是根据用户平时关注的内容挖掘的，因此有的人可能会显示文字新闻，有的人可能会是图片新闻等等。<br>我们先来仔细分析下这个需求，需求中的这些新闻大致可以分为相互独立的几种类型，对某类新闻做修改时不会影响到其他类的新闻，这样可以将每一类新闻抽象成面向对象编程中的一个类，然后在这些新闻类中挑选一些组合成需要的模块，这时候就可以用组合模式了。<br>在页面中，组合模式更常用在创建表单上，比如注册页面可能有不同的表单提交模块。对于这些需求，我们只需要有一个基本的个体，然后通过一定的组合即可实现。</p>
<p>收获与总结</p>
<p>组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了统一管理与使用。</p>
<p>享元模式</p>
<p>作者把享元模式比喻成城市公交车，可以仔细思考一番。</p>
<p>定义</p>
<p>运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>
<p>使用场景</p>
<p>现在有新闻的内容太多，我们有了一个分页显示所有新闻的需求。一个简单直观的做法就是页面加载后异步请求新闻数据，然后创建所有条新闻插入页面中，需要显示哪一页就显示哪一页。但是这样做有一个很大的问题，这样一下子创建几百条新闻同时插入页面会造成多页的开销严重影响网页的性能。这里的所有新闻都有相似的结构，只是内容不同罢了，对于这种相同结构造成多余开销的问题，可以用享元模式来解决。<br>享元模式 主要是对其数据、方法共享分离，将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或共有的数据和方法，所以将其提取出来减少开销。上面例子中，所有新闻个体都有共同的结构，应该作为内部数据，而下一页按钮绑定的事件则是外部方法。同时为了使用内部数据还需要提供一个操作方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var Flyweight = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 已创建的元素</span><br><span class="line">    var created = [];</span><br><span class="line">    // 创建一个新闻包装容器</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">create</span></span>() &#123;</span><br><span class="line">        var dom = document.createElement(<span class="string">'div'</span>);</span><br><span class="line">        // 将容器插入新闻列表容器中</span><br><span class="line">        document.getElementById(<span class="string">'container'</span>).appendChild(dom);</span><br><span class="line">        // 缓存新创建的元素</span><br><span class="line">        created.push(dom);</span><br><span class="line">        // 返回创建的新元素</span><br><span class="line">        <span class="built_in">return</span> dom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        // 获取创建新闻元素方法</span><br><span class="line">        getDiv: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            // 如果已创建的元素小于当前页元素总个数(5个)，则创建</span><br><span class="line">            <span class="keyword">if</span>(created.length &lt; 5) &#123;</span><br><span class="line">                <span class="built_in">return</span> created();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                // 获取第一个元素，并插入去后面</span><br><span class="line">                var div = created.shift();</span><br><span class="line">                created.push(div);</span><br><span class="line">                <span class="built_in">return</span> div;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面创建一个享元类，由于每页只能显示5条新闻，所以创建5个元素，保存在享元类内部，可以通过getDiv方法来获取创建的元素。下面就要实现外部数据和外部方法，外部数据就是我们要显示的所有新闻内容，由于每个内容都不一样肯定不能共享。首先，我们要根据新闻内容实例化页面，然后，对下一页绑定一个点击事件，显示下一页。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var paper = 0,</span><br><span class="line">    num = 5,</span><br><span class="line">    len = article.length;</span><br><span class="line">// 添加五条新闻</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(article[i])</span><br><span class="line">        // 通过享元类获取创建的元素并写入新闻内容</span><br><span class="line">        Flyweight.getDiv().innerHTML = article[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下一页按钮绑定事件</span><br><span class="line">document.getElementById(<span class="string">'next_page'</span>).onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 如果新闻内容不足5条则返回</span><br><span class="line">    <span class="keyword">if</span>(article.length &lt; 5) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    var n = ++paper * num % len,  // 获取当前页的第一条新闻索引</span><br><span class="line">        j = 0;</span><br><span class="line">    // 插入5条新闻</span><br><span class="line">    <span class="keyword">for</span>(; j &lt; 5; j++) &#123;</span><br><span class="line">        // 如果存在n+j条则插入</span><br><span class="line">        <span class="keyword">if</span>(article[n + j]) &#123;</span><br><span class="line">            Flyweight.getDiv().innerHTML = article[n + j];</span><br><span class="line">        // 否则插入起始位置第n+j-len条</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(article[n + j - len]) &#123;</span><br><span class="line">            Flyweight.getDiv().innerHTML = article[n + j - len];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight.getDiv().innerHTML = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样用享元模式对页面重构之后每次操作只需要操作5个元素，这样性能可以提高很多。</p>
<p>收获与总结</p>
<p>享元模式的应用是为了提高程序的执行效率与系统性能，因此在大型系统开发中应用比较广泛，可以避免程序中的数据重复。应用时一定要找准内部状态与外部状态，这样才能更合理地提取分离。</p>
<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。行为型设计模式主要有模板方法模式，观察者模式，状态模式，策略模式，职责链模式，命令模式，访问者模式，中介者模式，备忘录模式，迭代器模式和解释器模式，这么多的模式真得好好消化一阵子了。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>作者把这种模式比喻成照猫画虎。</p>
<p>定义</p>
<p>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类，使得子类可以不改变父类算法结构的同时可重新定义算法中某些实现步骤。</p>
<p>使用场景</p>
<p>提示框归一化，一个网站有很多页面，如果每个页面的弹出框样式不太一致就会显得不是很和谐，需要将他们的样式统一。新手最直观的想法就是去每个页面一个个修改，当然这样的代价是很大的，我们需要写一个弹出框插件，将这些弹出框封装好，然后再各个页面调用即可。这是在这个插件中就可以使用模板方法模式了，不需要重复写多个样式。<br>模板方法模式就是将多个模型抽象画归一，从中抽象出一个最基本的模板，这个模板可以作为实体也可以作为抽象对象，其他模块只需要继承这个模板方法，也可以扩展某些方法。<br>打个比方，我们生活中用蛋糕做模具做蛋糕，做出的蛋糕是外形相同的，因为他们都用同一个模具。然而商店里面卖的蛋糕是各式各样的，这都是对蛋糕的二次加工。我们的需求中基本提示框就是我们抽象出来的模具，其他提示框比这个提示框要多一些功能，我们只需要对他们做一些二次加工就能满足需求了。<br>模板方法不仅在归一化组件时使用，有时候创建页面时也是很常用的，比如创建三类导航，第一类是基础的，第二类是多了消息提醒功能的，第三类多了后面显示网址功能。这也可以用模板方法实现，此时抽象出来的基类是最简单的基础导航类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 格式化字符串方法</span><br><span class="line"><span class="keyword">function</span> formateString(str, data) &#123;</span><br><span class="line">    <span class="built_in">return</span> str.replace(/\&#123;<span class="comment">#(\w+)#\&#125;/g, function(match, key) &#123;</span></span><br><span class="line">        <span class="built_in">return</span> typeof data[key] === undefined ? <span class="string">''</span>: data[key]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 基础导航</span><br><span class="line">var Nav = <span class="keyword">function</span>(data) &#123;</span><br><span class="line">    // 基础导航样式模板</span><br><span class="line">    this.item = <span class="string">'&lt;a href="&#123;#href#&#125;" title="&#123;#title#&#125;"&gt;&#123;#name#&#125;&lt;/a&gt;'</span>;</span><br><span class="line">    // 创建字符串</span><br><span class="line">    this.html = <span class="string">''</span>;</span><br><span class="line">    // 格式化数据</span><br><span class="line">    <span class="keyword">for</span>(var i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">        this.html += formateString(this.item, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回字符串数据</span><br><span class="line">    <span class="built_in">return</span> this.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于消息提醒导航类，只需额外添加消息提醒组件模板，并与消息提醒组件模板对传入的网址数据进行装饰，得到所需的字符串，在调用从基类继承的方法处理这些字符串即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var NumNav = <span class="keyword">function</span>(data) &#123;</span><br><span class="line">    // 消息提醒信息组件模板</span><br><span class="line">    var tpl = <span class="string">'&lt;b&gt;&#123;#num#&#125;&lt;/b&gt;'</span>;</span><br><span class="line">    // 装饰数据</span><br><span class="line">    <span class="keyword">for</span>(var i = data.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        data[i].name += data[i].name + formateString(tpl, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 继承基础导航类</span><br><span class="line">    <span class="built_in">return</span> Nav.call(this, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>模板方法的核心在于对方法的重用，将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法共用。子类继承的方法是可扩展的，这就需要对基类继承的方法进行重写。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>作者把这种模式比喻成通信卫星。</p>
<p>定义</p>
<p>又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>
<p>使用场景</p>
<p>在团队开发中，经常是一个人负责一个模块，那么每人负责的模块之间要如何进行沟通呢？比如你实现一些需求需要添加一些代码，但是这个需求需要其他模块配合，但是每个模块都是不同人写的，你不想因为新添加的代码影响到他人实现的功能，这个时候就需要用到观察者模式了。<br>观察者模式就是为了解决主体对象与观察者之间的耦合。打个比方，目前每个国家都在研发并发射卫星，发射这些卫星是为了监控一些信息，那么它就可以被看做一个观察者或者说是一个消息系统，如果让这颗卫星为飞机导航，那么这架飞机就是一个被观察者或者说是一个主体对象。那么如果地面上的中转站或者其他飞机需要知道这架飞机的信息，于是每当飞机到达一个地方时就会向卫星发出位子信息，然后卫星又将信息广播到已经订阅这架飞机的中转站，这样就可以避免一些飞机事故发生。<br>这时候，观察者至少需要有两个方法，一个是接收某架飞机发来的消息，一个是向订阅的中转站发送响应消息。但是，并不是每个中转站都要时刻监控飞机状态的，所以还需要一个取消注册的方法。当然这些消息还需要保存，就需要一个保存消息的容器。这时候观察者雏形就出来了，他有一个消息容器和三个方法，订阅消息方法，取消订阅消息方法，发送订阅消息方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var Observer = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 防止消息队列暴露而被篡改，故将消息容器作为静态私有变量保存</span><br><span class="line">    var __messages = &#123;&#125;;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        // 注册信息接口</span><br><span class="line">        regist: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 发布信息接口</span><br><span class="line">        fire: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 移除信息接口</span><br><span class="line">        remove: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>下面就是可以自己具体实现这些接口了。</p>
<p>收获与总结</p>
<p>观察者模式最主要是解决类或对象之间的耦合，解耦两个互相依赖的对象，使其依赖于观察者的消息机制。这样对于任何一个订阅者来说，其他订阅者对象的改变不会影响到自身，其自身既可以是消息的发出者也可以是消息的执行者，这都依赖于调用观察者对象中的三种方法（订阅，注销，发布消息）中的哪一种。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>作者把这种模式比喻成超级玛丽。</p>
<p>定义</p>
<p>当一个对象内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对像。</p>
<p>使用场景</p>
<p>平时写代码的时候经常会遇到要写很多条件判断语句的情况，那么怎么减少代码中的条件判断语句呢？对于这类分支条件内部独立结果的管理，可以使用状态模式，每一种条件作为对象的一种状态，面对不同的判断结果，其实就是选择对象内的一种状态。<br>将不同的判断结果封装在状态对象内，然后该状态对象返回一个可被调用的接口方法，用于调用状态对象内部的某种方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 投票结果状态对象</span><br><span class="line">var ResultState = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 判断结果保存在内部状态中</span><br><span class="line">    var States = &#123;</span><br><span class="line">        // 每种状态作为一种独立方法保存</span><br><span class="line">        state0: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'这是第一种情况'</span>)：</span><br><span class="line">        &#125;,</span><br><span class="line">        state1: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'这是第二种情况'</span>)：</span><br><span class="line">        &#125;,</span><br><span class="line">        state2: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'这是第三种情况'</span>)：</span><br><span class="line">        &#125;,</span><br><span class="line">        state3: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'这是第四种情况'</span>)：</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取某种状态并执行对应方法</span><br><span class="line">    <span class="keyword">function</span> show(result) &#123;</span><br><span class="line">        States[<span class="string">'state'</span> + result] &amp;&amp; States[<span class="string">'state'</span> + result]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        // 返回调用状态方法接口</span><br><span class="line">        show: show</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>想调用第三种结果就可以如下调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ResultState.show(3);</span><br></pre></td></tr></table></figure>
<p>对于状态模式，主要目的就是将条件判断的不同结果转化为状态对象的内部状态，这个内部状态一般作为状态对象的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象即可。</p>
<p>收获与总结</p>
<p>状态模式既是解决程序中臃肿的分支判断语句问题，将每一个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次只需时遍历所有分支。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>作者把这种模式比喻成活诸葛。</p>
<p>定义</p>
<p>将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>
<p>使用场景</p>
<p>年底的时候，公司商品展销页都要开展大促销活动。在圣诞节，一部分商品5折出售，一部分商品8折出售，一部分商品9折出售，到元旦搞个幸运反馈活动，普通用户满100返30，高级VIP用户满100返50。这个时候上面的状态模式就不适用了，因为每一天每一个商品只有一种促销情况，这个时候可以用策略模式。<br>结构上看，它与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现实现对内部对象的调用，不同点是，策略模式不需要管理状态、状态间没有依赖关系、策略之剑可以相互替换、在策略对象内部保存的是相互独立的一些算法。看看策略对象的实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 价格策略对象</span><br><span class="line">var PriceStrategy = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 内部算法对象</span><br><span class="line">    var strategy = &#123;</span><br><span class="line">        // 100返30</span><br><span class="line">        return30: <span class="keyword">function</span>(price) &#123;&#125;,</span><br><span class="line">        // 100返50</span><br><span class="line">        return50: <span class="keyword">function</span>(price) &#123;&#125;,</span><br><span class="line">        // 9折</span><br><span class="line">        percent90: <span class="keyword">function</span>(price) &#123;&#125;,</span><br><span class="line">        // 8折</span><br><span class="line">        percent80: <span class="keyword">function</span>(price) &#123;&#125;,</span><br><span class="line">        // 5折</span><br><span class="line">        percent50: <span class="keyword">function</span>(price) &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    // 策略算法调用接口</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(algorithm, price) &#123;</span><br><span class="line">        <span class="built_in">return</span> strategy[algorithm] &amp;&amp; strategy[algorithm](price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>收获与总结</p>
<p>策略模式主要特色是创建一系列策略算法，每组算法处理业务都是相同的，只是处理的过程或者处理的结果不一样，所以它们是可以相互替换的，这样就解决了算法与使用者之间的耦合。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>作者把这种模式比喻成一个有序车站。</p>
<p>定义</p>
<p>解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，知道最后一个对象完成请求的处理。</p>
<p>使用场景</p>
<p>项目经理准备改善页面中的输入验证与提示交互体验。如用户在输入框输入信息后，在输入框的下面提示出一些备选项，当用户输入完成后，则要对用户输入信息进行验证等，页面中很多模块需要用户提交信息，为增强用户体验，这些输入框大部分需要具备以上两种功能。现在需要完成这个需求，但是以后可能要对原有表单交互体验做一些修改，也就是这是一个半成品需求。这种情况下，我们需要将需求里面需要做的每一件事情独立出来，这样完整的需求就变成一个个相互独立的模块需求，这样就不会因为以后需求的改变而影响我们项目的进展，这样还有利于以后的单元测试。这其实就是一种职责链模式。<br>对于上面的需求，对输入框绑定事件是第一部分，第二部分是创建xhr进行异步数据获取，第三部分就是适配响应数据，将接收到的数据格式化成可处理的形式，最后一部分是向组件创建器传入相应数据生成组件。</p>
<p>收获与总结</p>
<p>职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个最小分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，它可能是请求的发起者也可能是请求的接收者，通过这种方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与原请求的接收者之间的耦合。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>定义</p>
<p>将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。</p>
<p>使用场景</p>
<p>现在的需求是要做一个活动页面，平铺式的结构，不过页面的每个模块都有些相似的地方，比如每个预览产品图片区域，都有一行标题，然后标题下面是产品图片，只是图片的数量与排列不同。我们需要一种自由创建视图模块的方法，有时候创建多张图片有时候只创建一张图片，这时候可以试试命令模式。<br>命令模式是将创建模块的逻辑封装在一个对象里，这个对象提供一个参数化的请求接口，通过调用这个接口并传递一些参数实现调用命令对象内部中的一些方法。请求部分很简单，只需要按照给定参数格式书写指令即可，所以实现部分的封装才是重点，因为它要为请求部分提供所需方法。<br>那么哪些对象需要被命令化呢？既然需要动态展示不同模块，所以创建元素这一需求就是变化的，因此创建元素方法、展示方法应该被命令化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 模块实现模块</span><br><span class="line">var viewCommand = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var tpl = &#123;</span><br><span class="line">        // 展示图片结构模块</span><br><span class="line">        product: [</span><br><span class="line">            <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></span><br><span class="line">        ].join(<span class="string">''</span>),</span><br><span class="line">        // 展示标题结构模块</span><br><span class="line">        title: [</span><br><span class="line">        <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></span><br><span class="line">        ].join(<span class="string">''</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    // 格式化字符串缓存字符串</span><br><span class="line">    html = <span class="string">''</span>;</span><br><span class="line">    // 格式化字符串</span><br><span class="line">    <span class="keyword">function</span> formateString(str, obj) &#123;&#125;</span><br><span class="line">    // 方法集合</span><br><span class="line">    var Action = &#123;</span><br><span class="line">        // 创建方法</span><br><span class="line">        create: <span class="keyword">function</span>(data, view) &#123;</span><br><span class="line">            // 解析数据</span><br><span class="line">            <span class="keyword">if</span>(data.length) &#123;</span><br><span class="line">                // 遍历</span><br><span class="line">                <span class="keyword">for</span>(var i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">                    html += formateString(tpl[view], data[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html += formateString(tpl[view], data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 展示方法</span><br><span class="line">        display: <span class="keyword">function</span>(container, data, vuew) &#123;</span><br><span class="line">            // 如果传入数据</span><br><span class="line">            <span class="keyword">if</span>(data) &#123;</span><br><span class="line">                // 根据给的数据创建视图</span><br><span class="line">                this.create(data, view);</span><br><span class="line">            &#125;</span><br><span class="line">            // 展示模块</span><br><span class="line">            document.getElementById(container).innerHTML = html;</span><br><span class="line">            // 展示后清空缓存字符串</span><br><span class="line">            html = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 命令接口</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> excute(msg) &#123;</span><br><span class="line">        // 解析命令，如果msg.param不是数组则将其转化为数组</span><br><span class="line">        msg.param = Object.prototype.toString.call(msg.param) === <span class="string">"[object Array]"</span> ? msg.param : [msg.param];</span><br><span class="line">        // Action内部调用的方法引用this，此处保证作用域this执行传入Action</span><br><span class="line">        Action[msg.command].apply(Action, msg.param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>下面就可以测试这个命令对象了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var productData = [</span><br><span class="line">    &#123;</span><br><span class="line">        src: <span class="string">'command/02.jpg'</span>,</span><br><span class="line">        text: <span class="string">'绽放的桃花'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        src: <span class="string">'command/03.jpg'</span>,</span><br><span class="line">        text: <span class="string">'阳光下的温馨'</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">// 模块标题数据</span><br><span class="line">titleData = &#123;</span><br><span class="line">    title: <span class="string">'夏日里的一片温馨'</span>,</span><br><span class="line">    tips: <span class="string">'暖暖的温情带给人们家的感觉'</span></span><br><span class="line">&#125;</span><br><span class="line">// 调用命令对象</span><br><span class="line">viewCommand(&#123;</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">'display'</span>,</span><br><span class="line">    param: [<span class="string">'title'</span>, titleData, <span class="string">'title'</span>]</span><br><span class="line">&#125;);</span><br><span class="line">viewCommand(&#123;</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">'create'</span>,</span><br><span class="line">    param: [<span class="string">'product'</span>, productData, <span class="string">'product'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有了命令模式，想创建任何页面视图都是一件很简单的事情。</p>
<p>收获与总结</p>
<p>命令模式是将执行的命令封装，解决命令发起者与命令执行者之间的耦合，每一条命令实质上是一个操作。命令的是使用者不必了解命令执行者的命令接口是如何实现的，只需要知道如何调用。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>作者把这种模式比喻成驻华大使。</p>
<p>定义</p>
<p>针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的新方法。</p>
<p>使用场景</p>
<p>用DOM2级事件为页面中元素绑定事件时，为css设置一些样式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var bindEvent = <span class="keyword">function</span>(dom, <span class="built_in">type</span>, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</span><br><span class="line">        dom.addEventListener(<span class="built_in">type</span>, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</span><br><span class="line">        dom.attachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dom[<span class="string">'on'</span> + <span class="built_in">type</span>] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var demo = document.getElementById(<span class="string">'demo'</span>);</span><br><span class="line">bindEvent(demo, <span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.style.background = <span class="string">'red'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个在IE浏览器中会出问题，因为IE的attachEvent事件中this指向的竟然是window而不是这个元素，所以如果想获取事件对象必须用window.e来获取。这个问题可以借用访问者模式来解决。<br>访问者模式的思想是我们在不改变操作对象的同时，为它添加新的操作方法，来实现对操作对象的访问。下面看看IE的实现方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> bindIEEvent(dom, <span class="built_in">type</span>, fn, data) &#123;</span><br><span class="line">    var data = data || &#123;&#125;;</span><br><span class="line">    dom.attachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">        fn.call(dom, e, data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面实现方法的核心就是调用call方法，call方法的作用就是更改函数执行时的作用域，这正是访问者模式的精髓。</p>
<p>收获与总结</p>
<p>访问者模式解决数据与数据操作方法之间的耦合，将数据的操作方法独立于数据，使其可以自由化演变。访问者更适合那些数据稳定但是数据的操作方法易变的环境下。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>作者把这种模式比喻成媒婆，好吧，我笑了这里。</p>
<p>定义</p>
<p>通过中介者对象封装一系列对象之间的交互，是对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可以改变对象之间的交互。</p>
<p>使用场景</p>
<p>项目经理准备在用户首页上的导航模块添加一个设置层，让用户可以通过设置层来设置导航展开样式。但是页面中好多模块都有导航，这要改起来工作量也很大，上面讲的观察者模式虽然能解决模块之间的耦合，但是这里我们并没有需要向设置层发送请求的需求，设置层只是单向控制导航模块内导航的样式。这样的单向通信就可以使用中介者模式。<br>观察者模式和中介者模式都是通过消息收发机制实现，不过在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，而中介者模式中消息的发送方只有一个就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象（订阅者）才能订阅中介者消息。<br>如果用中介者模式来解决上面的问题，那么中介者对象就是设置层模块对象，它负责向各个导航模块对象发送用户设置消息，而各个导航模块则应该作为消息的订阅者存在，实现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 中介者对象</span><br><span class="line">var Mediator = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 消息对象</span><br><span class="line">    var _msg = &#123;&#125;;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        // 订阅消息方法，<span class="built_in">type</span>:消息名称 action:消息回调函数</span><br><span class="line">        register: <span class="keyword">function</span>(<span class="built_in">type</span>, action) &#123;</span><br><span class="line">            // 如果消息存在</span><br><span class="line">            <span class="keyword">if</span>(_msg[<span class="built_in">type</span>])</span><br><span class="line">                // 存入回调函数</span><br><span class="line">                _msg[<span class="built_in">type</span>].push(action);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                // 不存在则建立消息容器</span><br><span class="line">                _msg[<span class="built_in">type</span>] = [];</span><br><span class="line">                _msg[<span class="built_in">type</span>].push(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 发布消息方法</span><br><span class="line">        send: <span class="keyword">function</span>(<span class="built_in">type</span>) &#123;</span><br><span class="line">            // 如果该消息已经被订阅</span><br><span class="line">            <span class="keyword">if</span>(_msg[<span class="built_in">type</span>]) &#123;</span><br><span class="line">                // 遍历已存储的消息回调函数</span><br><span class="line">                <span class="keyword">for</span>(var i = 0, len = _msg[<span class="built_in">type</span>].length; i &lt; len; i++) &#123;</span><br><span class="line">                    // 执行回调函数</span><br><span class="line">                    _msg[<span class="built_in">type</span>][i] &amp;&amp; _msg[<span class="built_in">type</span>][i]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个中介者对象，下面就可以利用这个中介者对象完成我们的需求了。</p>
<p>收获与总结</p>
<p>同观察者模式一样，中介者模式的主要业务也是通过模块间或者对象间的复杂通信，来解决模块间或对象间的耦合。在中介者模式中，订阅者是单向的，只能是订阅者而不能是发布者。而消息统一由中介者对象发布。</p>
<p>备忘录模式</p>
<p>定义</p>
<p>在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部状态以便日后对象使用或者对象恢复到以前的某个状态。</p>
<p>使用场景</p>
<p>在前面提到的新闻页面中，有上一页和下一页的按钮，页面的内容是用异步请求获取的。如果点击下一页按钮接着再点击上一页那么之前那一页又要进行一次异步请求，这是多余的操作。因为第一次已经获取了数据，不需要再发送多余的请求。这个时候可以用备忘录模式来缓存请求过的数据。也就是说每次发生请求的时候对当前状态做一次记录，将请求到的数据以及对应得页码缓存下来，如果之后返回到之前浏览过的页面，直接在缓存中查询即可，不用发生异步请求。先创建一个新闻缓存器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Page备忘录类</span><br><span class="line">var Page = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 信息缓存对象</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(page, fn) &#123;</span><br><span class="line">        // 判断该页数据是否在缓存中</span><br><span class="line">        <span class="keyword">if</span>(cache[page]) &#123;</span><br><span class="line">            // 显示该页内容</span><br><span class="line">            showPage(page, cache[page]);</span><br><span class="line">            // 执行成功回调函数</span><br><span class="line">            fn &amp;&amp; fn();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // 否则异步请求</span><br><span class="line">            $.post(<span class="string">'./data/getNewsData.php'</span>, &#123;</span><br><span class="line">                page: page</span><br><span class="line">            &#125;, <span class="keyword">function</span>(res) &#123;</span><br><span class="line">                // 成功返回</span><br><span class="line">                <span class="keyword">if</span>(res.errNo == 0) &#123;</span><br><span class="line">                    showPage(page, res.data);</span><br><span class="line">                    cache[page] = res.data;</span><br><span class="line">                    fn &amp;&amp; fn();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    // 处理异常</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出Page缓存器内部缓存了每次请求回来的新闻数据，这样以后如果用户想回看某页新闻数据就不需要发送不必要的请求了。</p>
<p>收获与总结</p>
<p>备忘录模式最主要的任务是对现有的数据或状态进行缓存，为将类某个时刻使用或恢复做准备。但是当数据量过大时，会严重占用系统提供的资源，此时对缓存器的优化是很有必要的，复用率低的数据缓存下来是不值得的。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>作者把这种模式比喻成一个点钞机。</p>
<p>定义</p>
<p>在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>
<p>使用场景</p>
<p>迭代器模式主要是解决重复循环迭代的问题，之前接触过面向对象语言的应该都对迭代器有所了解。迭代器就是用来顺序地访问一个聚合对象内部元素的，它可以简化我们遍历操作，就行银行里的点钞机，有了它可以大幅度降低我们的点钞成本。下面创建一个常用的迭代器对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var Iterator = <span class="keyword">function</span>(items, container) &#123;</span><br><span class="line">    // 获取父元素</span><br><span class="line">    var container = container &amp;&amp; document.getElementById(container) || document,</span><br><span class="line">    // 获取元素</span><br><span class="line">        items = container.getElementsByTagName(items),</span><br><span class="line">    // 获取元素长度</span><br><span class="line">        length = items.length,</span><br><span class="line">    // 当前索引值</span><br><span class="line">        index = 0;</span><br><span class="line">    // 缓存原生数组splice方法</span><br><span class="line">    var splice = [].splice;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        // 获取第一个元素</span><br><span class="line">        first: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 获取最后一个元素</span><br><span class="line">        second: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 获取前一个元素</span><br><span class="line">        pre: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 获取后一个元素</span><br><span class="line">        next: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">        // 获取某一个元素</span><br><span class="line">        get: <span class="keyword">function</span>(num) &#123;&#125;,</span><br><span class="line">        // 对每一个元素执行某一个方法</span><br><span class="line">        dealEach: <span class="keyword">function</span>(fn) &#123;&#125;,</span><br><span class="line">        // 对某一个元素执行某一个方法</span><br><span class="line">        dealItem: <span class="keyword">function</span>(num, fn) &#123;&#125;,</span><br><span class="line">        // 排他方式处理某一个元素</span><br><span class="line">        exclusive: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面具体实现迭代器里面的这些方法，然后就可以用这个迭代器对象啦。</p>
<p>收获与总结</p>
<p>通过迭代器我们可以顺序地访问一个聚合对象中的每一个元素。在开发中，迭代器极大简化了代码中的循环语句，使代码结构清晰紧凑。用迭代器去处理一个对象时，只需要提供处理的方法，而不必去关心对象的内部结构，这也解决了对象的使用者与对象内部结构之间的耦合。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义</p>
<p>对于一种语言，给出其文法表示，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>
<p>使用场景</p>
<p>一个页面中的某些功能好坏有时是靠一定的数据依据支撑的。项目经理想看看用户对最近新增的功能使用情况，前后端要给出统计数据，然而前端交互统计项中要给出交互元素路径。这件事情与冒泡事件类似，只不过在这个路径中还要关心同一层级中当前元素的兄弟元素。比如下面的结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div calss=<span class="string">"wrap"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"link-inner"</span>&gt;</span><br><span class="line">        &lt;a href=<span class="string">"#"</span>&gt;link&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"button-inner"</span>&gt;</span><br><span class="line">        &lt;button&gt;text&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>要获取button相对于class为wrap的div元素的Xpath路径，那么可以表示为DIV&gt;DIV2&gt;SPAN。<br>上面对需求的描述是一种文法，描述的是一组规则，现在要做的事实现一个规则解释器来解释上面的规则。首先要分析给出的文法，查找他们的相似点，然后该清楚我们要先实现什么再实现什么，基本上问题就能解决了。</p>
<p>收获与总结</p>
<p>一些描述性语句，几次功能的提取抽象，形成了一套语法法则，这就是解释器模式要处理的事情。是否能应用解释器模式的一条重要准则是能否根据需求解析出一套完整的语法规则，不论该语法规则简单或是复杂都是必须的。</p>
<h1 id="技巧型设计模式"><a href="#技巧型设计模式" class="headerlink" title="技巧型设计模式"></a>技巧型设计模式</h1><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。这本书中总结了8种技巧型设计模式，分别是链模式，委托模式，数据访问对象模式，节流模式，简单模板模式，惰性模式，参与者模式和等待者模式。有兴趣的同学可以去买书来看哦，这里就不一一解释了。</p>
<h1 id="架构型设计模式"><a href="#架构型设计模式" class="headerlink" title="架构型设计模式"></a>架构型设计模式</h1><p>架构型设计模式是一类框架结构，通过提供一些子系统，指定它们的职责，并将它们条理清晰地组织在一起。现在流行的前端框架都用了这种类型的设计模式。本书总结了6种架构型设计模式，分别是同步模块模式，异步模块模式，Widget模式，MVC模式，MVP模式和MVVM模式。</p>
<p>学习设计模式的学习对于我们来说任重而道远，我们需要在实践中不断思考不断总结。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>神书推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>是export还是module.exports，是import还是require，是ES6还是CommonJS，是爱❤️还是责任？</title>
    <url>/2019/12/10/module/</url>
    <content><![CDATA[<p>故事要从一次错误的编码开始。。。<br><a id="more"></a></p>
<h1 id="Node的模块"><a href="#Node的模块" class="headerlink" title="Node的模块"></a>Node的模块</h1><p>众所周知，在上古年代，node的开发一直被 Commonjs 规范所支配着，这也是悲剧发生的导火索，请看灾难现场：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// version.js</span></span><br><span class="line"><span class="keyword">var</span> version = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  version++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  version,</span><br><span class="line">  incVersion,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./version'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod.version);  <span class="comment">// 3</span></span><br><span class="line">mod.incVersion();</span><br><span class="line"><span class="built_in">console</span>.log(mod.version); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这，这一瞬间，时间的涡轮好像停止了一样，版本号变量<font color="green"><em>version</em></font>一直停留在3永不向前，就好像我的人生那样，停滞不前，是命运的捉弄，还是人为的操控呢？</p>
<p>不，是值的拷贝，CommonJS 模块输出的是值的拷贝，也就是说，mod.version是一个原始类型的值，会被缓存，那么我们怎样解决这个问题呢?<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 可以改写成函数</span><br><span class="line"><span class="keyword">var</span> version = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  version++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">get</span> version() &#123;</span><br><span class="line">    <span class="keyword">return</span> version</span><br><span class="line">  &#125;,</span><br><span class="line">  incVersion,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者用es6的import引用，那么这又是什么呢，敲黑板，画重点，要考。</p>
<h1 id="ES6-模块与-CommonJS-模块"><a href="#ES6-模块与-CommonJS-模块" class="headerlink" title="ES6 模块与 CommonJS 模块"></a>ES6 模块与 CommonJS 模块</h1><p>它们有两个重大差异。</p>
<blockquote>
<p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>
</blockquote>
<blockquote>
<p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">CommonJS</th>
<th style="text-align:center">ES6</th>
<th style="text-align:center">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">exports</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">x</td>
<td style="text-align:center">是 module.exports 的一个引用</td>
</tr>
<tr>
<td style="text-align:center">module.exports</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">x</td>
<td style="text-align:center">module.exports = xxx，就是导出xxx</td>
</tr>
<tr>
<td style="text-align:center">export</td>
<td style="text-align:center">x</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">多个</td>
</tr>
<tr>
<td style="text-align:center">export default</td>
<td style="text-align:center">x</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">单个</td>
</tr>
<tr>
<td style="text-align:center">require</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">导出的内容是module.exports的指向的内存块内容/ es6时是一个对象（{default:xxx}）</td>
</tr>
<tr>
<td style="text-align:center">import</td>
<td style="text-align:center">x</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">引用多个</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无聊的冷门尝试 es6试用require</span></span><br><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">123</span></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a) <span class="comment">//&#123;default: 123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a) <span class="comment">//&#123;a: 123&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="exports-和-module-exports"><a href="#exports-和-module-exports" class="headerlink" title="exports 和 module.exports"></a>exports 和 module.exports</h2><p>在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，<br>而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/module/exports.png" alt></p>
<h2 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h2><p>首先我们讲这两个导出，下面我们讲讲它们的区别</p>
<ol>
<li><font color="pink">export</font>与<font color="pink">export default</font>均可用于导出常量、函数、文件、模块等</li>
<li>在一个文件或模块中，<font color="pink">export</font>、<font color="pink">import</font>可以有多个，<font color="pink">export default</font>仅有一个</li>
<li>通过<font color="pink">export</font>方式导出，在导入时要加{}，<font color="pink">export default</font>则不需要</li>
<li><font color="pink">export</font>能直接导出变量表达式，<font color="pink">export default</font>不行。</li>
</ol>
<h1 id="天坑-循环依赖"><a href="#天坑-循环依赖" class="headerlink" title="天坑-循环依赖"></a>天坑-循环依赖</h1><p>“循环依赖”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>); <span class="comment">//a-step 1</span></span><br><span class="line"><span class="built_in">module</span>.exports.value = <span class="string">'a'</span>; <span class="comment">//a-step 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">//b-step 1</span></span><br><span class="line"><span class="built_in">module</span>.exports.value = <span class="string">'b'</span>; <span class="comment">//b-step 2</span></span><br></pre></td></tr></table></figure></p>
<p>一般很少会这样写，出现的话证明你的功能逻辑有耦合了，应该先分开，但是一些大型项目就很难避免，小弟不才，真的遇到过。</p>
<p>node的执行顺序</p>
<blockquote>
<p>a-step 1 –&gt; b-step 1 –&gt; b-step 2 –&gt; a-step 2</p>
</blockquote>
<p> 当年的黑科技临时解决办法，其实不建议，就是将a中的a-step 2移到a-step 1之上。<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.value = <span class="string">'a'</span>; <span class="comment">//a-step 2</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>); <span class="comment">//a-step 1</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>上面的其实是<strong>Commonjs</strong>版的，<strong>es6</strong>的解决方法有点不一样，具体就是将要引用的变量改成函数，因为函数具有提升作用，在加载时就已经有定义了。（ps:改成了函数表达式也不行，因为不具有提升作用）</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>那么在座各位天才小儿童，肯定能想到怎样用es6解决那个灾难现场了吧，答案就是直接用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> version = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  version ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; version, incVersion &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; version, incVersion &#125; <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'version'</span>, version )</span><br><span class="line">incVersion()</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'version'</span>, version )</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>JS填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>完成的项目，持续更新</title>
    <url>/2018/08/14/project/</url>
    <content><![CDATA[<p>目标：写过的代码加起来能绕地球一圈</p>
<h2 id="那是梦开始的地方"><a href="#那是梦开始的地方" class="headerlink" title="那是梦开始的地方"></a>那是梦开始的地方</h2><a id="more"></a>
<h3 id="第一个小程序，IoT项目"><a href="#第一个小程序，IoT项目" class="headerlink" title="第一个小程序，IoT项目"></a>第一个小程序，IoT项目</h3><p><img src="/images/project/iot_user.jpg" alt><br>IoT安装端账号：az1 密码：123456<br><img src="/images/project/iot_install.jpg" alt><br>IoT售后端账号：wx1 密码：123456<br><img src="/images/project/iot_wx.jpg" alt></p>
<h3 id="车仔网小程序"><a href="#车仔网小程序" class="headerlink" title="车仔网小程序"></a>车仔网小程序</h3><p><img src="/images/project/chezi.png" alt></p>
<h3 id="男士理容预约小程序"><a href="#男士理容预约小程序" class="headerlink" title="男士理容预约小程序"></a>男士理容预约小程序</h3><p><img src="/images/project/harroman.jpg" alt></p>
<h3 id="vue搭建的手机商城"><a href="#vue搭建的手机商城" class="headerlink" title="vue搭建的手机商城"></a>vue搭建的手机商城</h3><p><img src="/images/project/shilianmobile.png" alt></p>
<h3 id="飞冰Ice后台demo"><a href="#飞冰Ice后台demo" class="headerlink" title="飞冰Ice后台demo"></a>飞冰Ice后台demo</h3><p><a href="http://hospital.pppppxt.cc" target="_blank" rel="noopener">demo链接,点我,点我</a><br>管理员账户：admin;医生账号：doctor 密码都是：123456</p>
<h3 id="某题库测试系统前端demo"><a href="#某题库测试系统前端demo" class="headerlink" title="某题库测试系统前端demo"></a>某题库测试系统前端demo</h3><p><a href="http://wuweiquan.pppppxt.cc" target="_blank" rel="noopener">点我,点我</a><br>sn码随便输入即可</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>react核心</title>
    <url>/2021/06/21/react/</url>
    <content><![CDATA[<h2 id="react-的fiber"><a href="#react-的fiber" class="headerlink" title="react 的fiber"></a>react 的fiber</h2><p>有5个优先级的等级</p>
<ul>
<li>Immediate</li>
<li>UserBlocking</li>
<li>Normal</li>
<li>Low</li>
<li>Idle</li>
</ul>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><h3 id="怎么写一个高阶组件？"><a href="#怎么写一个高阶组件？" class="headerlink" title="怎么写一个高阶组件？"></a>怎么写一个高阶组件？</h3><ol>
<li>普通方式</li>
<li>装饰器</li>
<li>多个高阶组件组合</li>
</ol>
<h3 id="高阶组件-1"><a href="#高阶组件-1" class="headerlink" title="高阶组件"></a>高阶组件</h3><ol>
<li><p>属性代理</p>
<p>1、操作props<br>2、操作ref</p>
</li>
<li><p>继续/劫持</p>
</li>
</ol>
<h2 id="什么是react-hooks-优势"><a href="#什么是react-hooks-优势" class="headerlink" title="什么是react hooks?优势"></a>什么是react hooks?优势</h2><p>useState<br>useEffect<br>useMemo</p>
<h2 id="react-hooks-有什么优势"><a href="#react-hooks-有什么优势" class="headerlink" title="react hooks 有什么优势"></a>react hooks 有什么优势</h2><h3 id="class-的缺点"><a href="#class-的缺点" class="headerlink" title="class 的缺点"></a>class 的缺点</h3><ol>
<li>组件间的状态逻辑很难复用</li>
<li>复杂业务的有状态组件会越来越复杂</li>
<li>监听和定时器的操作，被分散在多个区域</li>
</ol>
<p>不要在render里写bind</p>
<h3 id="hooks-的优点"><a href="#hooks-的优点" class="headerlink" title="hooks 的优点"></a>hooks 的优点</h3><ol>
<li>利于业务逻辑的封装和拆分，可以自由自定义hooks(自己封装的用到了react hooks的公共逻辑)<br>useEffect(()=&gt;{})</li>
<li>可以在无需修改组件结构的情况下，复用状态逻辑</li>
<li>定时器、监听等等都被聚合到同一块代码下</li>
</ol>
<h3 id="hooks使用注意事项"><a href="#hooks使用注意事项" class="headerlink" title="hooks使用注意事项"></a>hooks使用注意事项</h3><ol>
<li>不能在循环判断里用<br>索引问题</li>
<li>只能在 React 的函数组件中调⽤ Hook，不要在其他 JavaScript 函数中调⽤</li>
<li>自定义的hook怎样操作组件</li>
</ol>
<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2>]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>React-native,我们一起走过的坑。</title>
    <url>/2018/04/19/rn/</url>
    <content><![CDATA[<p>前几个星期，点开了RN的技能树，废话不多说，那我就意简言赅地记录一下自己遇到的坑，避免后人再犯自己的错误。<br><a id="more"></a><br>先说明一下我的运行环境：<br>1.我当时这个年代用的RN版本是0.55<br>2.使用的脚手架是create-react-native-app</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="EJECT前（即生成那个android和ios文件前）"><a href="#EJECT前（即生成那个android和ios文件前）" class="headerlink" title="EJECT前（即生成那个android和ios文件前）"></a>EJECT前（即生成那个android和ios文件前）</h2><p>如果你像我那样，按照官方的说明方法：初始化了一个项目<br>但也是找不到android和ios文件的话，不要慌张，要淡定，因为这时你还没有EJECT，官方解析就是：<br>“eject” eventually to create your own native builds<br>但是，是男人的话怎么能那么快eject的，所以这时就该大名鼎鼎的’Expo’登场了，你只需要在你的手机或者模拟器上安装上这个最新版的’Expo’软件，然后在你的本地项目运行命令npm start，这时不出意料的话你就会弹出一个二维码出来（但是不知为何我每次都是出意外地弹了一个崩了的二维码），在你的Expo上扫一扫就能运行成功了，当然最后是少不摇一摇你的手机打开调试，Android模拟器：Command⌘ + M，iOS模拟器：Command⌘ + D，打开Enable Live Reload,然后你就能愉快地撸码了。<br>但是身为一个前端工程师，一眼见不到那个盒子模型，心里总会不舒服的，这时，你只要执行上面一样的操作，选择Show inspector就行了。<br><img src="/images/Developer Menu.jpg" alt></p>
<h2 id="EJECT后"><a href="#EJECT后" class="headerlink" title="EJECT后"></a>EJECT后</h2><p>这时候，情况就比较尴尬了<br>这时你已经进入了贤者模式，而你的项目结构也会发生一些微妙的变化，看你能不能找出来，找出来后，这时候你要面对就是那个android文件夹和ios文件夹，身为一个只懂JS的前端工程师的我来说，一开始我是拒绝的<br>但是深入理解之后，我发现我其实根本不用管它们的。<br>当运行npm run android/npm run ios后，你的手机/模拟器毫无意外就会被强制地安装上了一个应用了，这时候调试同上的。</p>
<blockquote>
<p>总结<br>普通手机应用的话还是eject后真机模拟器调试方便的，不竟后面还有一些你预想不到的一些npm模块居然还要更改android文件什么才能用的，哼(￢︿̫̿￢☆)<br>如果你那么不幸，像我一样要开发什么鬼特制机的话，那些机全身上下只有一些USB接口，而接上电脑后又完全没有响应的话，这时候EXPO那骚一般的远程调试就适合不过了</p>
</blockquote>
<h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><h2 id="不能继承-不能继承-不能继承"><a href="#不能继承-不能继承-不能继承" class="headerlink" title="不能继承 不能继承 不能继承"></a>不能继承 不能继承 不能继承</h2><p>好吧，我先深呼吸一下，先放些代码给大家感受下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">    &lt;Text style=&#123;styles.text&#125;&gt;&lt;/Text&gt;</span><br><span class="line">    &lt;Text style=&#123;styles.text&#125;&gt;&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  view: &#123;</span><br><span class="line">    width:300,</span><br><span class="line">  &#125;，</span><br><span class="line">  text：&#123;</span><br><span class="line">    fontSize:10,   </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你想把这个view里面的text字体都设为10的话怎么办？<br>嗯，没错，你只能乖乖地每一个text都写上一个样式了。<br>好吧，首先我们要知道它是模仿css的规则的而已，所以也就只能这样了。</p>
<h2 id="默认尺寸是DP"><a href="#默认尺寸是DP" class="headerlink" title="默认尺寸是DP"></a>默认尺寸是DP</h2><p>百分比不能用<br>可以用flex:1,flex:2,做等比例</p>
<h1 id="组件坑"><a href="#组件坑" class="headerlink" title="组件坑"></a>组件坑</h1><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="要先设宽高"><a href="#要先设宽高" class="headerlink" title="要先设宽高"></a>要先设宽高</h3><p>为了性能方便所有网络图片都要先设固定宽高（来自官方傲娇的解析）<br>像这样<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> &lt;Image </span><br><span class="line">    style=&#123;&#123;width: 100, height: 100&#125;&#125;</span><br><span class="line">    <span class="built_in">source</span>=&#123;&#123;uri: url&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，我特么的怎么知道图片的尺寸是什么。<br>解决方法：<br>1、使用Image自带的getSize方法先获取宽高<br>2、使用别的大神的组件React Native Fit Image 等</p>
<h3 id="资源超过400kb左右不显示"><a href="#资源超过400kb左右不显示" class="headerlink" title="资源超过400kb左右不显示"></a>资源超过400kb左右不显示</h3><p>所以说原生组件，😔<br>推荐使用别的组件库：react-native-fast-image（要先装个glide，略为麻烦）</p>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>source={require(‘./xxx.jpg’)} 资源路径不能拼接，但可以这样写<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const a=require(<span class="string">'./xxx/'</span>)</span><br><span class="line">&lt;Image <span class="built_in">source</span>=&#123;a&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="点击事件尽量使用Touchable开头的"><a href="#点击事件尽量使用Touchable开头的" class="headerlink" title="点击事件尽量使用Touchable开头的"></a>点击事件尽量使用Touchable开头的</h2><h2 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h2><p>官方推荐的路由组件库<br>我使用StackNavigator方法<br>坑1： navigation.goBack()，返回上一个页面所有生命周期都没有进入，不像小程序有一个onShow周期<br>坑2：navigation.goBack()，不能带参数<br>我的解决办法：<br>1、把方法传进下一个页面，goBack()前调用<br>2、传入route_key，使用setParams方法传参</p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>建议按官网流程<br>我踩过的坑：index.js 里的 registerComponent 不同app要不一样</p>
<p><em>未完待续</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>JS填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>一些前端题目</title>
    <url>/2018/03/22/test-list/</url>
    <content><![CDATA[<h1 id="整理一下一些前端题目"><a href="#整理一下一些前端题目" class="headerlink" title="整理一下一些前端题目"></a>整理一下一些前端题目</h1><a id="more"></a>
<h2 id="以下分别输出什么-为什么"><a href="#以下分别输出什么-为什么" class="headerlink" title="以下分别输出什么,为什么"></a>以下分别输出什么,为什么</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var User = &#123;</span><br><span class="line">  count: 1,</span><br><span class="line">  getCount: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(User.getCount());  // what?</span><br><span class="line">var func = User.getCount;</span><br><span class="line">console.log(func());  // what?</span><br></pre></td></tr></table></figure>
<p>答案是:1和undefined。</p>
<h2 id="以下代码执行结果是什么"><a href="#以下代码执行结果是什么" class="headerlink" title="以下代码执行结果是什么"></a>以下代码执行结果是什么</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  var foo = 1,bar = 2,j,<span class="built_in">test</span>;</span><br><span class="line">  <span class="built_in">test</span> = <span class="keyword">function</span>(j) &#123;</span><br><span class="line">      j = 5;</span><br><span class="line">      var bar = 5;</span><br><span class="line">      foo = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">test</span>(10);</span><br><span class="line">  console.log(foo); //</span><br><span class="line">  console.log(bar); //</span><br><span class="line">  console.log(j); //</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(User.getCount());  // what?</span><br><span class="line">var func = User.getCount;</span><br><span class="line">console.log(func());  // what?</span><br></pre></td></tr></table></figure>
<p>答案是:5 2 undefined。</p>
<h2 id="说出输出的结果顺序"><a href="#说出输出的结果顺序" class="headerlink" title="说出输出的结果顺序"></a>说出输出的结果顺序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(<span class="keyword">function</span> executor(resolve) &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  <span class="keyword">for</span>( var i=0 ; i&lt;10000 ; i++ ) &#123;</span><br><span class="line">    i == 9999 &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br></pre></td></tr></table></figure>
<p>答案：“2 3 5 4 1”</p>
<h2 id="以下代码执行结果是什么-1"><a href="#以下代码执行结果是什么-1" class="headerlink" title="以下代码执行结果是什么"></a>以下代码执行结果是什么</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;this.value = 42;&#125;</span><br><span class="line">foo.prototype = &#123;method: <span class="function"><span class="title">function</span></span> () &#123;<span class="built_in">return</span> <span class="literal">true</span>;&#125;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">    var value = 1;</span><br><span class="line">    <span class="built_in">return</span>&#123;method:<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> value;&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo.prototype = new bar();</span><br><span class="line">console.log(foo.prototype.constructor); //</span><br><span class="line">console.log(foo.prototype instanceof  bar); //</span><br><span class="line">var <span class="built_in">test</span> = new foo();</span><br><span class="line">console.log(<span class="built_in">test</span> instanceof foo);//</span><br><span class="line">console.log(<span class="built_in">test</span> instanceof bar);//</span><br><span class="line">console.log(test.method());//</span><br></pre></td></tr></table></figure>
<p>答案：ƒ Object() { [native code] }<br>      False<br>      true<br>      false<br>      1</p>
<h2 id="用纯css-html写一个导航栏的tab切换-不使用js"><a href="#用纯css-html写一个导航栏的tab切换-不使用js" class="headerlink" title="用纯css,html写一个导航栏的tab切换(不使用js)"></a>用纯css,html写一个导航栏的tab切换(不使用js)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方法1：</span><br><span class="line">&lt;ul class=<span class="string">'nav'</span>&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=<span class="string">"#content1"</span>&gt;列表1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=<span class="string">"#content2"</span>&gt;列表2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div id=<span class="string">"content1"</span>&gt;列表1内容:123456&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"content2"</span>&gt;列表2内容:abcdefgkijkl&lt;/div&gt;</span><br><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">	<span class="comment">#content1,</span></span><br><span class="line">	<span class="comment">#content2&#123;</span></span><br><span class="line">	    display:none;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">#content1:target,</span></span><br><span class="line">	<span class="comment">#content2:target&#123;</span></span><br><span class="line">	    display:block;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#content1:target ~ .nav li&#123;</span></span><br><span class="line">	    // 改变li元素的背景色和字体颜色</span><br><span class="line">	    &amp;:first-child&#123;</span><br><span class="line">	        background:<span class="comment">#ff7300;</span></span><br><span class="line">	        color:<span class="comment">#fff;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#content2:target ~ .nav li&#123;</span></span><br><span class="line">	    // 改变li元素的背景色和字体颜色</span><br><span class="line">	    &amp;:last-child&#123;</span><br><span class="line">	        background:<span class="comment">#ff7300;</span></span><br><span class="line">	        color:<span class="comment">#fff;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">方法2：</span><br><span class="line">&lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;input class=<span class="string">"nav1"</span> id=<span class="string">"li1"</span> <span class="built_in">type</span>=<span class="string">"radio"</span> name=<span class="string">"nav"</span>&gt;</span><br><span class="line">    &lt;input class=<span class="string">"nav2"</span> id=<span class="string">"li2"</span> <span class="built_in">type</span>=<span class="string">"radio"</span> name=<span class="string">"nav"</span>&gt;</span><br><span class="line">    &lt;ul class=<span class="string">'nav'</span>&gt;</span><br><span class="line">        &lt;li class=<span class="string">'active'</span>&gt;&lt;label <span class="keyword">for</span>=<span class="string">"li1"</span>&gt;列表1&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;label <span class="keyword">for</span>=<span class="string">"li2"</span>&gt;列表2&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=<span class="string">"content"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"content1"</span>&gt;列表1内容:123456&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"content1"</span>&gt;列表2内容:abcdefgkijkl&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">	.container&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">    width:400px;</span><br><span class="line">    margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line">input&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br><span class="line">.nav&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    <span class="built_in">float</span>:left;</span><br><span class="line">    text-align:center;</span><br><span class="line">    background:<span class="comment">#ddd;</span></span><br><span class="line">&#125;</span><br><span class="line">li label&#123;</span><br><span class="line">    display:block;</span><br><span class="line">    width:200px;</span><br><span class="line">    line-height:36px;</span><br><span class="line">    font-size:18px;</span><br><span class="line">    cursor:pointer;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    width:400px;</span><br><span class="line">    height:100px;</span><br><span class="line">    border:1px solid <span class="comment">#999;</span></span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">    padding:10px;</span><br><span class="line">&#125;</span><br><span class="line">.content1,</span><br><span class="line">.content2&#123;</span><br><span class="line">    display:none;</span><br><span class="line">    width:100%;</span><br><span class="line">    height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.nav1:checked ~ .nav li &#123;</span><br><span class="line">    background:<span class="comment">#ddd;</span></span><br><span class="line">    color:<span class="comment">#000;</span></span><br><span class="line">    </span><br><span class="line">    &amp;:first-child&#123;</span><br><span class="line">        background:<span class="comment">#ff7300;</span></span><br><span class="line">        color:<span class="comment">#fff;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.nav2:checked ~ .nav li&#123;</span><br><span class="line">    background:<span class="comment">#ddd;</span></span><br><span class="line">    color:<span class="comment">#000;</span></span><br><span class="line">    </span><br><span class="line">    &amp;:last-child&#123;</span><br><span class="line">        background:<span class="comment">#ff7300;</span></span><br><span class="line">        color:<span class="comment">#fff;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.nav1:checked ~ .content &gt; div&#123;</span><br><span class="line">    display:none;</span><br><span class="line">    </span><br><span class="line">    &amp;:first-child&#123;</span><br><span class="line">    display:block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.nav2:checked ~ .content &gt; div&#123;</span><br><span class="line">    display:none;</span><br><span class="line">    </span><br><span class="line">    &amp;:last-child&#123;</span><br><span class="line">    display:block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.active &#123;</span><br><span class="line">        background:<span class="comment">#ff7300;</span></span><br><span class="line">        color:<span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br><span class="line">.default&#123;</span><br><span class="line">    display:block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="编写程序，统计字符串var-str-”helloworld”-中每种字符出现的次数-出现次数最多的是-出现-次"><a href="#编写程序，统计字符串var-str-”helloworld”-中每种字符出现的次数-出现次数最多的是-出现-次" class="headerlink" title="编写程序，统计字符串var str=”helloworld”;中每种字符出现的次数,出现次数最多的是? 出现?次"></a>编写程序，统计字符串var str=”helloworld”;中每种字符出现的次数,出现次数最多的是? 出现?次</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str=<span class="string">"helloworld"</span>;</span><br><span class="line">  方法一：用<span class="built_in">hash</span></span><br><span class="line">  <span class="keyword">for</span>(var i=0,<span class="built_in">hash</span>=&#123;&#125;;i&lt;str.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">hash</span>[str[i]])&#123;</span><br><span class="line">      <span class="built_in">hash</span>[str[i]]++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">hash</span>[str[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.dir(<span class="built_in">hash</span>);</span><br><span class="line">方法二：用正则</span><br><span class="line">var arr=str.split(<span class="string">""</span>)</span><br><span class="line">  .sort()</span><br><span class="line">  .join(<span class="string">""</span>)</span><br><span class="line">  .match(/([a-z])\1*/g)</span><br><span class="line">  .sort(<span class="keyword">function</span>(a,b)&#123;</span><br><span class="line"><span class="built_in">return</span> b.length-a.length; &#125;)</span><br><span class="line">console.log(<span class="string">"出现最多的是: "</span>+arr[0][0]</span><br><span class="line">  +<span class="string">"共"</span>+arr[0].length+<span class="string">"次"</span>);</span><br><span class="line">var <span class="built_in">hash</span>=&#123;&#125;;</span><br><span class="line">  arr.forEach(<span class="keyword">function</span>(val)&#123;</span><br><span class="line">    <span class="built_in">hash</span>[val[0]]=val.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  console.dir(<span class="built_in">hash</span>);</span><br></pre></td></tr></table></figure>
<h2 id="民间有一直有一游戏，玩法就是，大家轮流报数，如果报到能被7整除的数字，或者尾数是7的数字，都算踩地雷了。就应该罚唱歌。"><a href="#民间有一直有一游戏，玩法就是，大家轮流报数，如果报到能被7整除的数字，或者尾数是7的数字，都算踩地雷了。就应该罚唱歌。" class="headerlink" title="民间有一直有一游戏，玩法就是，大家轮流报数，如果报到能被7整除的数字，或者尾数是7的数字，都算踩地雷了。就应该罚唱歌。"></a>民间有一直有一游戏，玩法就是，大家轮流报数，如果报到能被7整除的数字，或者尾数是7的数字，都算踩地雷了。就应该罚唱歌。</h2><p>请编写程序，输出1~60之间的所有“安全数”<br>比如：<br>1、2、3、4、5、6、8、9、10、11、12、13、15、16、18、19、20、22、23、24、25、26、29、30……</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 1; i &lt;= 60 ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%7 == 0 || i%10 == 7)&#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浏览器输入url到完整显示出页面经历的过程"><a href="#浏览器输入url到完整显示出页面经历的过程" class="headerlink" title="浏览器输入url到完整显示出页面经历的过程"></a>浏览器输入url到完整显示出页面经历的过程</h2><p>第一种简单的说呢就是这样的：<br>第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器。<br>第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回。<br>第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。<br>第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。<br>第五步：重复第四步,直到找到正确的纪录。</p>
<h2 id="机试题"><a href="#机试题" class="headerlink" title="机试题"></a>机试题</h2><p> ·点击某个节点元素，则该节点元素呈现一个特殊被选中的样式<br> ·增加一个删除按钮，当选中某个节点元素后，点击删除按钮，则将该节点及其所有子节点删除掉<br> ·增加一个输入框及一个“添加”按钮当选中某个节点元素后，点击增加按钮，则在该节点下增加一个子节点，节·点内容为输入框中内容，插入在其子节点的最后一个位置<br> ·提供一个按钮，显示开始遍历，点击后，以动画的形式呈现遍历的过程<br> ·当前被遍历到的节点做一个特殊显示（比如不同的颜色）<br> ·每隔一段时间（500ms，1s等时间自定）再遍历下一个节点<br> ·增加一个输入框及一个“查询”按钮，点击按钮时，开始在树中以动画形式查找节点内容和输入框中内容一致的节点，找到后以特殊样式显示该节点，找不到的话给出找不到的提示。查询过程中的展示过程和遍历过程保持一致</p>
<p><a href="http://ife.baidu.com/2016/task/all" target="_blank" rel="noopener">神奇的链接</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title>this/必包/作用域</title>
    <url>/2021/05/02/this-%E5%BF%85%E5%8C%85-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>bind可以传基本类型，只会绑定一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.bind(<span class="number">1</span>).bind(<span class="number">2</span>)() <span class="comment">// Number &#123;1&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>three笔记</title>
    <url>/2022/05/04/three/</url>
    <content><![CDATA[<blockquote>
<p>three的笔记学习-一开始总以为是tree，原来是three，感觉就是3d，然后很多三角形的意思</p>
</blockquote>
<h2 id="一开"><a href="#一开" class="headerlink" title="一开"></a>一开</h2>]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记</title>
    <url>/2019/05/19/typescript-note/</url>
    <content><![CDATA[<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>‘TypeScript’-顾名思义，就是有Type的Script<br><a id="more"></a></p>
<hr>
<p>那么它和没有Type的Script有什么不一样呢，例如某Java前缀的Script<br>举个例子：实际开发需求中我们要定义一个商品名称的变量为goodsName(<font color="red">ps:众所周知商品名称都必须是要字符串的</font>)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js中定义一个变量,先赋值一个字符串</span></span><br><span class="line"><span class="keyword">let</span> goodsName = <span class="string">'apple'</span> <span class="comment">// 很好，看起来都一起正常</span></span><br><span class="line"><span class="comment">// 然鹅，一位刚失恋的程序员哥哥，不小心把它改成一个数字（说笑，程序员哪会有女朋友）</span></span><br><span class="line">goodsName = <span class="number">520</span> <span class="comment">// 这时候程序也没有阻止小哥哥这种赤裸裸的示爱行为</span></span><br><span class="line"><span class="comment">// 甚至可以改成布尔值</span></span><br><span class="line">goodsName = <span class="literal">true</span></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// 可以想想刚失恋的小哥哥，把这个变量提交给后端的接口</span></span><br><span class="line"><span class="comment">// 最后给产品发现了</span></span><br><span class="line"><span class="comment">// 后端调查发现是前端提交的数据类型错误</span></span><br><span class="line"><span class="comment">// 顺利摔锅给前端</span></span><br><span class="line"><span class="comment">// 从此小哥哥就步入了人生的低谷，情场事业双失😔</span></span><br></pre></td></tr></table></figure></p>
<p>然而如果这时候这位程序员小哥哥用上了TypeScript<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上也先定义一个变量</span></span><br><span class="line"><span class="keyword">let</span> goodsName: string = <span class="string">'apple'</span> <span class="comment">// 看看有什么不同？没错，就是多了个string</span></span><br><span class="line">goodsName = <span class="number">520</span> <span class="comment">//这时候就会有一条红线在变量下方</span></span><br><span class="line"><span class="comment">// Error, number不是string类型</span></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// 看到这条提示的红线，小哥哥也终于意识到了</span></span><br><span class="line"><span class="comment">// 他的爱情也像这条红线那样</span></span><br><span class="line"><span class="comment">// 已经到了高亮的结束边缘</span></span><br><span class="line"><span class="comment">// 最后小哥哥看着那条红线</span></span><br><span class="line"><span class="comment">// 突然对爱情重拾希望，然后不顾红线的错误提示，提交给后端</span></span><br><span class="line"><span class="comment">// 结局同上</span></span><br></pre></td></tr></table></figure></p>
<h2 id="一些踩过的坑"><a href="#一些踩过的坑" class="headerlink" title="一些踩过的坑"></a>一些踩过的坑</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意数量的其它属性"><a href="#任意数量的其它属性" class="headerlink" title="任意数量的其它属性"></a>任意数量的其它属性</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line"> [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    <span class="built_in">readonly</span> x: number;</span><br><span class="line">    <span class="built_in">readonly</span> y: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1: Point = &#123; x: 10, y: 20 &#125;;</span><br><span class="line">p1.x = 5; // error!</span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//方法1</span><br><span class="line"><span class="keyword">function</span> add(x: number, y: number): number &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法2</span><br><span class="line"><span class="built_in">let</span> myAdd = <span class="keyword">function</span>(x: number, y: number): number &#123; <span class="built_in">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>提示真的很爽</li>
<li>会增加写类型的时间</li>
<li>大型项目来说上面花的时间是值得的，后期维护时间会变少</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>JS填坑</tag>
      </tags>
  </entry>
  <entry>
    <title>vue核心</title>
    <url>/2021/06/21/vue/</url>
    <content><![CDATA[<h3 id="why-O-n"><a href="#why-O-n" class="headerlink" title="why O(n)?"></a>why O(n)?</h3><p>严格意义不是真的O(n),复杂度其实是O(nm)</p>
<h3 id="how-O-n"><a href="#how-O-n" class="headerlink" title="how O(n)?"></a>how O(n)?</h3><p>同层级比较</p>
<h3 id="用index做key"><a href="#用index做key" class="headerlink" title="用index做key"></a>用index做key</h3><p>vue: [0,1,2],[0,1] 误删<br>react: 会重新渲染 都是新建</p>
<h3 id="虚拟dom过程"><a href="#虚拟dom过程" class="headerlink" title="虚拟dom过程"></a>虚拟dom过程</h3><p> 虚拟 DOM</p>
<ol>
<li><p>什么是虚拟 DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> type: <span class="string">'div'</span>,</span><br><span class="line"> props: &#123;</span><br><span class="line"> children: []</span><br><span class="line"> &#125;,</span><br><span class="line"> el: xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么创建虚拟 DOM</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-&gt; h 、createElement...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, props</span>) </span>&#123; <span class="keyword">return</span> &#123; type, props &#125; &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用呢</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JSX:</span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;ul className=<span class="string">'padding-20'</span>&gt;</span><br><span class="line">   &lt;li key=<span class="string">'li-01'</span>&gt;<span class="keyword">this</span> is li <span class="number">01</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p> 经过一些工具转一下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line"> children: [</span><br><span class="line">   createElement(<span class="string">'ul'</span>, &#123; <span class="attr">className</span>: <span class="string">'padding-20'</span> &#125;,</span><br><span class="line">   createElement(<span class="string">'li'</span>, &#123; <span class="attr">key</span>: <span class="string">'li-01'</span>&#125;, <span class="string">'this is li 01'</span>))</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>虚拟DOM的数据结构有了，那就是渲染了 (mount/render)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f(vnode) -&gt; view</span><br><span class="line"></span><br><span class="line">f(vode) &#123;</span><br><span class="line"><span class="built_in">document</span>.createElement();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">parent.insert()</span><br><span class="line">. insertBefore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="function">(<span class="params">vnode, parent</span>) =&gt;</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">'app'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>diff 相关了(patch)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f(oldVnodeTree, newVnodeTree, parent) -&gt; 调度? -&gt; view</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2021/05/29/webpack/</url>
    <content><![CDATA[<h3 id="我们常说的Module是什么"><a href="#我们常说的Module是什么" class="headerlink" title="我们常说的Module是什么"></a>我们常说的Module是什么</h3><p>webpack支持 ESModule, CommonJS, AMD, Assests</p>
<h3 id="如何表达各种依赖关系？"><a href="#如何表达各种依赖关系？" class="headerlink" title="如何表达各种依赖关系？"></a>如何表达各种依赖关系？</h3><h3 id="我们常说的chunk和bundle的区别是什么？（important！）"><a href="#我们常说的chunk和bundle的区别是什么？（important！）" class="headerlink" title="我们常说的chunk和bundle的区别是什么？（important！）"></a>我们常说的chunk和bundle的区别是什么？（important！）</h3><ol>
<li><p>Chunk<br>是Webpack打包过程中Modules的集合，是<code>打包过程</code>中的概念。<br>Webpack的打包是从⼀个⼊⼝模块开始，⼊⼝模块引⽤其他模块，模块再引⽤模块。<br>Webpack通过引⽤关系逐个打包模块，这些module就形成了⼀个Chunk。<br>当然如果有多个⼊⼝模块，可能会产出多条打包路径，每条路径都会形成⼀个Chunk。</p>
</li>
<li><p>bundle<br>Bundle是我们最终输出的⼀个或多个打包好的⽂件</p>
</li>
<li><p>Chunk 和 Bundle 的关系?<br>大多数情况，一个chunk一个bundle</p>
</li>
</ol>
<h3 id="Plugin-和-Loader-分别做什么？怎样工作的？"><a href="#Plugin-和-Loader-分别做什么？怎样工作的？" class="headerlink" title="Plugin 和 Loader 分别做什么？怎样工作的？"></a>Plugin 和 Loader 分别做什么？怎样工作的？</h3><ol>
<li>Loader<br>模块转换器，将非js模块转化为webpack能识别的</li>
<li>Plugin<br>扩展插件,webpack各个阶段都会广播出对应的事件</li>
<li><p>Compiler<br>对象，也可以理解为webpack的实例</p>
</li>
<li><p>Compliation<br>模块资源</p>
</li>
</ol>
<h3 id="简单描述一下打包过程"><a href="#简单描述一下打包过程" class="headerlink" title="简单描述一下打包过程"></a>简单描述一下打包过程</h3><ol>
<li>初始化参数：shell webpack.config.js</li>
<li>开始编译</li>
<li>确定入口</li>
<li>编译模块</li>
<li>完成模块编译</li>
<li>输出资源</li>
</ol>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序填坑日记</title>
    <url>/2017/06/14/wehchat-small/</url>
    <content><![CDATA[<p>记录一下那些年，开发微信小程序踩过的坑<br><a id="more"></a></p>
<h1 id="微信小程序认识"><a href="#微信小程序认识" class="headerlink" title="微信小程序认识"></a>微信小程序认识</h1><h2 id="总体认识"><a href="#总体认识" class="headerlink" title="总体认识"></a>总体认识</h2><p>隐约感受到的RN的身影<br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html" target="_blank" rel="noopener">官方的Q&amp;A文档</a></p>
<blockquote>
<p>为什么脚本内不能使用window等对象<br>页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件</p>
</blockquote>
<p>碰巧RN也是通过JsCore与手机的原生语言通信的，简单来说它只不过是以 JavaScript 的形式告诉 Objective-C /java该执行什么代码<br>反正我们知道它能直接调用微信本身的控件就行了</p>
<h2 id="小体认识"><a href="#小体认识" class="headerlink" title="小体认识"></a>小体认识</h2><p><em>MVVM</em>,<em>前后端分离</em>,<em>数据绑定</em>,<em>数据驱动</em><br><img src="/images/model.png" alt></p>
<h1 id="一些代码"><a href="#一些代码" class="headerlink" title="一些代码"></a>一些代码</h1><p>自定义弹框<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;view hidden=<span class="string">"&#123;&#123;showTrue&#125;&#125;"</span>&gt;&lt;/view&gt;</span><br><span class="line">&lt;view wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;showTrue&#125;&#125;"</span>&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>
<p>改变样式<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;view class=<span class="string">"&#123;&#123;diyClassName&#125;&#125;"</span>&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">最重要的当然是官方文档</a><br><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">微信小程序资源汇总</a><br><a href="https://github.com/chemzqm/wept" target="_blank" rel="noopener">用chrome运行小程序</a><br><a href="https://github.com/Hao-Wu/WeApp-Demo" target="_blank" rel="noopener">官方demo源码</a></p>
<h1 id="填过的坑"><a href="#填过的坑" class="headerlink" title="填过的坑"></a>填过的坑</h1><p>1.透明底的png图片,border-raduis：50%会变形<br>2.canvas在swiper和scroll-view不兼容会浮出来<br>3.iphone：scroll-view内部滚动必须设置高度，在iphone不能设100%,可以通过js设高度或设固定值<br>4.iphone：image图片里padding不能设百分比,只能设固定值<br>5.最多只能打开5个页面,注意一下页面跳转的关闭</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>【重学前端】面向对象/原型链/继承</title>
    <url>/2021/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><h2 id="类数组转换成数组"><a href="#类数组转换成数组" class="headerlink" title="类数组转换成数组"></a>类数组转换成数组</h2><p> 1.[…arguments].slice()<br> 2.Array.prototype.slice.apply(arguments)<br> 3.Array.from(arguments).slice()</p>
<h3 id="鸡生蛋"><a href="#鸡生蛋" class="headerlink" title="鸡生蛋"></a>鸡生蛋</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title>重学数据结构和算法</title>
    <url>/2021/07/18/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h2><p>建立变量存数据</p>
<h2 id="数据处理的基本操作"><a href="#数据处理的基本操作" class="headerlink" title="数据处理的基本操作"></a>数据处理的基本操作</h2><p><code>增、删、查</code></p>
<ul>
<li><p>首先，这段代码对数据进行了哪些操作？</p>
</li>
<li><p>其次，这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？</p>
</li>
<li><p>最后，哪种数据结构最能帮助你提高数据操作的使用效率？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>数据结构、算法</tag>
      </tags>
  </entry>
</search>
